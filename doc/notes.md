No, Hedera is not a blockchain. Instead, Hedera uses a different form of distributed ledger technology called hashgraph, which is based on a directed acyclic graph (DAG) structure. Unlike blockchains, which organize data into sequential blocks, hashgraph weaves all events together without discarding any, resulting in higher efficiency, speed, and security. This approach allows Hedera to process transactions more quickly and with lower fees than traditional blockchains, while also being more energy-efficient [Hedera Defined & Explained](https://hedera.com/learning/hedera-hashgraph/what-is-hedera-hashgraph?) [Blockchain and Edge Computing: A Powerful Data Duo](https://hedera.com/learning/data/blockchain-and-edge-computing) [DAG vs Blockchain: A Look at the Pluses and Minuses](https://hedera.com/learning/distributed-ledger-technologies/dag-vs-blockchain).

..........................................................................................
Hedera has several distinctive qualities, as described in the knowledge sources:

- **Not a Blockchain**: Hedera uses the hashgraph consensus algorithm, which is a directed acyclic graph (DAG) rather than a traditional blockchain structure. This allows for higher efficiency and throughput [Hedera Defined & Explained](https://hedera.com/learning/hedera-hashgraph/what-is-hedera-hashgraph?).

- **Performance**: Capable of processing hundreds of thousands of transactions per second in a single shard, with consensus latency measured in seconds, not minutes or hours [Hedera: A Public Hashgraph Network & Governing Council](https://files.hedera.com/hh_whitepaper_v2.2-20230918.pdf).

- **Security**: Achieves asynchronous Byzantine Fault Tolerance (aBFT), the gold standard for security in distributed systems, and is resistant to Distributed Denial of Service (DDoS) attacks [What are distributed ledger technologies (DLTs)?](https://hedera.com/learning/distributed-ledger-technologies/what-are-distributed-ledger-technologies-dlts?) [Hedera: A Public Hashgraph Network & Governing Council](https://files.hedera.com/hh_whitepaper_v2.2-20230918.pdf).

- **Fairness**: Ensures fairness in the order of transactions, preventing individuals or small groups from manipulating transaction order. There is no concept of leaders or miners who can prioritize transactions for higher fees [Hedera Consensus Service Whitepaper](https://hedera.com/hh-consensus-service-whitepaper.pdf).

- **Energy Efficiency**: Does not require energy-intensive mining, making it much more energy-efficient and inexpensive to operate compared to proof-of-work blockchains [What is hashgraph consensus?](https://hedera.com/learning/hedera-hashgraph/what-is-hashgraph-consensus).

- **Predictable and Low Fees**: Transaction fees are predictable and not subject to bidding wars or congestion pricing [Blockchain Transactions: A Behind-the-Scenes Look](https://hedera.com/learning/distributed-ledger-technologies/blockchain-transactions).

- **Decentralized Governance**: Governed by the Hedera Governing Council, a rotating group of leading global organizations from diverse industries and geographies, each with equal voting rights and term limits to ensure decentralization [Hedera Defined & Explained](https://hedera.com/learning/hedera-hashgraph/what-is-hedera-hashgraph?).

- **No Forking**: The governance and licensing model is designed to eliminate the risk of forking, protecting the integrity of the codebase [Hedera: A Public Hashgraph Network & Governing Council](https://files.hedera.com/hh_whitepaper_v2.2-20230918.pdf).

- **Open Source**: Both the hashgraph algorithm and Hedera’s implementation are open sourced under an Apache 2.0 license [Hedera Defined & Explained](https://hedera.com/learning/hedera-hashgraph/what-is-hedera-hashgraph?).

- **Tamper-Apparent**: Any tampering with the ledger is apparent to all network participants, ensuring transparency [What are distributed ledger technologies (DLTs)?](https://hedera.com/learning/distributed-ledger-technologies/what-are-distributed-ledger-technologies-dlts?).

- **Multiple Services**: Offers smart contracts, consensus, and token services for building decentralized applications [Hedera Defined & Explained](https://hedera.com/learning/hedera-hashgraph/what-is-hedera-hashgraph?).

If you need more specific qualities or details, please clarify your request!


...............................................................................
The main objective of the Hedera Governing Council is to provide decentralized, stable, and effective governance for the Hedera network. The Council is responsible for overseeing key aspects such as software upgrades, network pricing, treasury management, and regulatory compliance. Its structure—composed of up to 39 leading global organizations from diverse industries and geographies, each with equal voting rights and term limits—ensures that no single entity or group can dominate decision-making. This governance model is designed to maintain the long-term interests, stability, and decentralization of the Hedera network, while eliminating risks like forks and safeguarding the integrity of the platform [Hedera Defined & Explained](https://hedera.com/learning/hedera-hashgraph/what-is-hedera-hashgraph) [HH Hbar Economics Whitepaper](https://hedera.com/hh-hbar-coin-economics-paper-060320-v6.pdf) [Hedera: A Public Hashgraph Network & Governing Council](https://files.hedera.com/hh_whitepaper_v2.2-20230918.pdf).


.................................................................................
The areas of responsibility of the Hedera Governing Council, as described in the knowledge sources, include:

- **Participating in the governance of the Hedera network**: This involves making decisions on software updates, network rules, and the overall direction of the platform.
- **Hosting and maintaining nodes**: Council members are responsible for running the initial nodes of the Hedera network.
- **Treasury management**: Overseeing the management and security of the Hedera Treasury, including the control and distribution of HBAR tokens.
- **Network pricing**: Setting and approving network transaction fees and pricing models.
- **Regulatory compliance**: Advising and ensuring the network adheres to relevant legal and regulatory requirements.
- **Oversight of software development**: Guiding the technical roadmap and approving changes to the platform codebase.
- **Committee participation**: Council members serve on various committees, such as finance, technical steering, membership, legal & regulatory, and marketing, to address specific aspects of network governance.
- **Ensuring decentralization and stability**: The Council is structured to prevent any single entity or group from gaining control, thus maintaining the network’s decentralization and long-term stability.

These responsibilities are designed to ensure the effective, decentralized, and transparent governance of the Hedera network [HH Hbar Economics Whitepaper](https://hedera.com/hh-hbar-coin-economics-paper-060320-v6.pdf) [Hedera Defined & Explained](https://hedera.com/learning/hedera-hashgraph/what-is-hedera-hashgraph) [Hedera Hashgraph Governing Council Names Brett McDowell as Executive Director and Vice Chair, Establishes Council Committees](https://hedera.com/blog/hedera-hashgraph-governing-council-names-brett-mcdowell-as-executive-director-and-vice-chair-establishes-council-committees) [DLA Piper: The future of public distributed ledgers in law and why we joined the Hedera Governing Council](https://hedera.com/blog/dla-piper-the-future-of-public-distributed-ledgers-in-law-and-why-we-joined-the-hedera-governing-council).

...............................................................................

Here are features that are **not typical of web2 software development but are features of Hedera**:

- **Decentralized, pseudonymous accounts**: Hedera accounts are identified by pseudonymous IDs (e.g., 0.0.1234) and controlled by cryptographic keys, removing the need for personal metadata like email and password, which are common in web2 [PROTECTION ON HEDERA > DATA ON HEDERA](https://hedera.com/HH_Web-3-Privacy-Architecture_20211111.pdf).

- **Consensus via hashgraph algorithm**: Hedera uses the hashgraph consensus algorithm, providing high throughput, fairness in transaction ordering, and asynchronous Byzantine Fault Tolerance (aBFT)—features not present in web2 systems [Hedera: A Public Hashgraph Network & Governing Council](https://files.hedera.com/hh_whitepaper_v2.2-20230918.pdf).

- **Immutable, distributed ledger**: Data and transactions are stored immutably across a distributed network, rather than in centralized databases as in web2 [PROTECTION ON HEDERA > BUILDING PRIVACY INTO DAPPS](https://hedera.com/HH_Web-3-Privacy-Architecture_20211111.pdf).

- **User-controlled privacy and non-custodial models**: In Hedera, users can interact directly with the network using their own keys, without relying on centralized intermediaries, enabling privacy-centric, non-custodial applications [PROTECTION ON HEDERA > BUILDING PRIVACY INTO DAPPS](https://hedera.com/HH_Web-3-Privacy-Architecture_20211111.pdf).

- **Decentralized governance**: The Hedera Governing Council, composed of global organizations with equal voting rights and term limits, governs the network—unlike the centralized control typical in web2 platforms [Hedera: A Public Hashgraph Network & Governing Council](https://files.hedera.com/hh_whitepaper_v2.2-20230918.pdf).

- **Open, tamper-apparent data**: All transactions and changes are visible and verifiable by anyone, ensuring transparency and auditability, which is not a default feature in web2 [PROTECTION ON HEDERA > DATA ON HEDERA](https://hedera.com/HH_Web-3-Privacy-Architecture_20211111.pdf).

These features distinguish Hedera and web3 development from traditional web2 software development.

....................................................................................
The phase of network growth that includes **permissionless nodes** is **Phase 3**. In this phase, any person or organization will be able to run a Hedera mainnet consensus node with anonymity, and node operators receive hbars for contributing to consensus and providing services [HH Decentralization of Consensus Whitepaper](https://files.hedera.com/hh-decentralization-of-consensus.pdf).

............................................................................

The characteristic that describes the **future state of node operation on the Hedera network** is **Public Permissionless**. In this state, anyone can run a node anonymously and participate in network consensus, which is the most decentralized form of distributed ledger technology [Hedera Defined & Explained](https://hedera.com/learning/hedera-hashgraph/what-is-hedera-hashgraph?) [HH Decentralization of Consensus Whitepaper](https://files.hedera.com/hh-decentralization-of-consensus.pdf).


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Today, Hedera is best described as **Public Permissioned**. This means anyone can use the network to create accounts and deploy applications, but only invited and approved entities (the Hedera Governing Council members) can operate consensus nodes [Hedera Defined & Explained](https://hedera.com/learning/hedera-hashgraph/what-is-hedera-hashgraph?) [HH Decentralization of Consensus Whitepaper](https://files.hedera.com/hh-decentralization-of-consensus.pdf).

............................................................................
Yes, blockchains are a form of distributed ledger technology (DLT). Distributed ledger technologies are peer-to-peer networks that enable multiple members to maintain their own identical copy of a shared ledger, and blockchain is one type of DLT where data is stored in blocks that are linked together in order of creation [What are distributed ledger technologies (DLTs)?](https://hedera.com/learning/distributed-ledger-technologies/what-are-distributed-ledger-technologies-dlts?) [Blockchain and Digital Transformation](https://hedera.com/learning/distributed-ledger-technologies/digital-transformation).
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

The correct answer is **Mainnet**.

Mainnet is the production Hedera network where real-value transactions occur, and transaction fees are paid in real HBAR. This is where applications are run in production, and users interact with the network in a live environment with actual costs. In contrast, Previewnet and Testnet are for development and testing, and the Local Network is for local development only, without real-value transactions or costs [Mainnet Overview](https://docs.hedera.com/hedera/networks/mainnet) [Hedera Release Cycle Overview](https://hedera.com/blog/hedera-release-cycle-overview).

The correct answer is **Previewnet**.

Previewnet is described as a network where "accounts / data are likely to be lost when the network codebase is upgraded" because it runs a codebase still under development, and stability is not guaranteed [The Hedera previewnet is now live](https://hedera.com/blog/the-hedera-previewnet-is-now-live).


The correct answer is **Mirror node**.

Mirror nodes on Hedera are specifically designed to provide analytical insight into an application’s state and transactions. They store and make available historical and real-time ledger information, enabling queries, analytics, audit support, and monitoring without impacting the performance of consensus nodes [What is the Hedera mirror network?](https://hedera.com/learning/hedera-hashgraph/what-is-the-hedera-mirror-network?) [Understanding Mirror Nodes](https://docs.hedera.com/hedera/core-concepts/mirror-nodes#understanding-mirror-nodes).


The characteristics of Consensus Nodes, based on the provided knowledge sources, are:

- **A: Can submit HAPI (Hedera API) transactions to the Hedera network**
- **C: Requires HBAR cryptocurrency payment for transactions & queries**

**Explanation:**
- Consensus nodes can submit HAPI transactions to the Hedera network and require HBAR payment for processing transactions and queries [What is the Hedera mirror network?](https://hedera.com/learning/hedera-hashgraph/what-is-the-hedera-mirror-network?).
- Maintaining a history of the ledger (B) and publish/subscribe capabilities (D) are characteristics of mirror nodes, not consensus nodes.

So, the correct choices are **A** and **C**.


The Hedera network services, according to the provided knowledge sources, are:

- **A. Hedera Token Service**
- **B. Hedera Smart Contract Service**
- **D. Hedera Consensus Service**

There is no mention of a "Hedera Token Contract Service" as a network service in the knowledge sources. The official services are Token Service, Smart Contract Service, and Consensus Service [Hedera Network Services](https://docs.hedera.com/hedera#hedera-network-services) [Services Overview](https://github.com/hashgraph/hedera-services/blob/main/hedera-node/docs/design/services/services.md).

The correct answer is:

**D. True for Hedera Mirror Node Rest API**

You can look up transaction history and filter by account, balance, transaction, topic, token, NFT, smart contract, and more using the Hedera Mirror Node REST API. This is explicitly described in the knowledge sources, which state that the Mirror Node REST API enables you to query transactions and account information, and filter by various criteria such as account, balance, transaction, topic, token, NFT, and smart contract [How to Use Mirror Nodes?](https://hedera.com/blog/how-to-look-up-transaction-history-on-hedera-using-mirror-nodes-back-to-the-basics) [Mirror Node REST API](https://docs.hedera.com/hedera/sdks-and-apis/rest-api).

The other options are incorrect:
- Consensus nodes do not provide this level of historical query and filtering.
- The statement is not false for the Mirror Node REST API; it is true.
- There is no "Hedera Consensus Node Rest API" for this purpose.

The correct answer is **B. Hedera File Service**.

The Hedera File Service is used for decentralized file storage and is often used in conjunction with other services to store data such as smart contract bytecode or token metadata. It is specifically mentioned as being used for "smart contract storage" among other use cases [Hedera File Service](https://github.com/hashgraph/hedera-services/blob/main/hedera-node/docs/design/services/services.md).


The correct answer is **B. Hedera File Service**.

The Hedera File Service is used for decentralized file storage and is often used in conjunction with other services to store data such as smart contract bytecode or token metadata. It is specifically mentioned as being used for "smart contract storage" among other use cases [Hedera File Service](https://github.com/hashgraph/hedera-services/blob/main/hedera-node/docs/design/services/services.md).

The use cases of the Hedera Consensus Service, according to the knowledge sources, are:

- **A. Event ordering**  
- **B. Integrity Check**  
- **D. Timestamping**  

**Event ordering** and **timestamping** are core features of HCS, providing decentralized, fair, and verifiable ordering of events with trusted timestamps [Hedera Consensus Service](https://hedera.com/learning/hedera-hashgraph/what-is-hedera-hashgraph) [Consensus Service Design](https://github.com/hashgraph/hedera-services/blob/main/hedera-node/docs/design/services/consensus-service/consensus-service.md).  
**Integrity check** is enabled by submitting hashes of data to HCS, allowing verification that data has not been tampered with [Data Timestamping for Data Integrity](https://hedera.com/blog/pragmatic-blockchain-design-patterns-integrating-blockchain-into-business-processes).

There is no explicit mention of **de-duplication** as a use case for HCS in the provided knowledge sources.

HTS stands for **Hedera Token Service** [Hedera Token Service (HTS) Native Tokenization](https://docs.hedera.com/hedera/core-concepts/tokens/hedera-token-service-hts-native-tokenization) [Glossary: Hedera Token Service (HTS)](https://docs.hedera.com/hedera/support-and-community/glossary#hedera-token-service-hts).

A. True

It is possible to use the Hedera Token Service (HTS) without prior Solidity or smart contract programming capabilities. HTS allows you to configure, mint, and manage tokens directly using Hedera’s APIs and SDKs, without the need to set up or deploy a smart contract Hedera Token Service - Part 1: How to Mint NFTs Glossary: Hedera Token Service (HTS).

**A. True**

The Hedera Smart Contract Service can be used to build auctions and bridges. It allows developers to deploy and interact with smart contracts on the Hedera network, enabling decentralized applications (dApps) with complex logic and automated processes, such as auctions and interoperability bridges [Services Overview](https://github.com/hashgraph/hedera-services/blob/main/hedera-node/docs/design/services/services.md).

HBAR is the native, utility token of the Hedera network. Its primary utilities are:

- **Transaction Fees:** HBAR is used to pay for transaction and query fees across all Hedera network services, including cryptocurrency transfers, smart contracts, token creation, consensus, and file storage. All fees are paid in HBAR (or its smallest unit, tinybar), making it essential for any activity on the network [Hedera > Core-concepts > Accounts](https://docs.hedera.com/hedera/core-concepts/accounts).

- **Network Security & Staking:** HBAR is staked to nodes to secure the network through Hedera’s proof-of-stake consensus. The amount of HBAR staked to a node determines its influence on consensus, helping to protect against attacks and ensuring network integrity. HBAR holders can also proxy-stake their tokens to nodes and earn rewards for contributing to network security [Hedera > Core-concepts > Staking](https://docs.hedera.com/hedera/core-concepts/staking), [HH Hbar Economics Whitepaper](https://hedera.com/hh-hbar-coin-economics-paper-060320-v6.pdf).

- **Node and Staking Rewards:** HBAR is used to reward node operators for providing computing resources and, through proxy staking, to reward HBAR holders who delegate their tokens to nodes [HH Hbar Economics Whitepaper](https://hedera.com/hh-hbar-coin-economics-paper-060320-v6.pdf).

- **Micropayments:** HBAR enables fast, low-cost micropayments, making it suitable for use cases like pay-per-use content, streaming, and other microtransaction-based applications. Real-world examples include platforms like Dropp and Tune.fm, which use HBAR for instant, direct payments [Hedera Blog: Micropayment Platform Dropp](https://hedera.com/blog/micropayment-platform-dropp-debuts-putting-pay-as-you-go-option-in-reach-of-both-merchants-and-consumers), [Hedera Blog: The Tune.fm JAM Token](https://hedera.com/blog/the-tune-fm-jam-token-journey-to-the-hedera-token-service).

- **Fuel for Decentralized Applications:** HBAR is required to deploy and interact with decentralized applications (dApps) on Hedera, serving as the “fuel” for the network [Learning Article: What is Hedera Hashgraph?](https://hedera.com/learning/hedera-hashgraph/what-is-hedera-hashgraph).

In summary, HBAR is essential for paying network fees, securing the network through staking, rewarding participants, and enabling a wide range of decentralized applications and micropayment use cases on Hedera.

Certainly! Here’s an explanation of each of the three types of fees that make up the Hedera transaction fee:

---

### 1. **Node Fee**
The **Node Fee** compensates the individual node that receives and submits your transaction to the network. When a user or application sends a transaction, it is first sent to a single node. This node expends resources (such as CPU and bandwidth) to process and forward the transaction. The Node Fee is paid directly from the end user’s account to the account of the node that submits the transaction. This incentivizes nodes to participate in the network and handle user requests efficiently.  
[HH Hbar Economics Whitepaper](https://hedera.com/hh-hbar-coin-economics-paper-060320-v6.pdf), [Payments and fees Part 1](https://files.hedera.com/hh_whitepaper_v2.2-20230918.pdf)

---

### 2. **Network Fee**
The **Network Fee** compensates all participating nodes for the work involved in gossiping the transaction, validating digital signatures, and reaching consensus. After the initial node submits the transaction, it is communicated to other nodes, which temporarily store it and participate in consensus. The Network Fee is paid into a Hedera Treasury account, and a portion of these collected fees is distributed daily to nodes as rewards for their participation in consensus.  
[HH Hbar Economics Whitepaper](https://hedera.com/hh-hbar-coin-economics-paper-060320-v6.pdf), [Payments and fees Part 1](https://files.hedera.com/hh_whitepaper_v2.2-20230918.pdf)

---

### 3. **Service Fee**
The **Service Fee** compensates the network for the specific service requested by the transaction, such as transferring cryptocurrency, executing a smart contract, storing a file, or submitting a message. The amount of the Service Fee depends on the resources consumed (e.g., storage size, computation required, or duration of storage). Service Fees are paid by users into a Hedera Treasury account, and a portion is distributed to nodes as rewards.  
[Payments and fees Part 2](https://files.hedera.com/hh_whitepaper_v2.2-20230918.pdf), [HH Hbar Economics Whitepaper](https://hedera.com/hh-hbar-coin-economics-paper-060320-v6.pdf)

---

**Summary Table:**

| Fee Type    | Purpose                                                      | Recipient                |
|-------------|--------------------------------------------------------------|--------------------------|
| Node Fee    | Compensates submitting node for processing the transaction   | Submitting node account  |
| Network Fee | Compensates all nodes for consensus and validation work      | Hedera Treasury account  |
| Service Fee | Compensates for the specific service requested (e.g., storage, smart contract execution) | Hedera Treasury account  |

If you need more technical details or examples, let me know!

Yes, fees on Hedera are based on the United States Dollar (USD). All transaction and query fees are fixed in USD, but they are paid in HBAR. The network regularly updates the exchange rate between USD and HBAR to ensure that the USD value of fees remains stable, even as the price of HBAR fluctuates. This approach provides predictable and stable costs for users and developers on the network [Hedera Stable fees](https://hedera.com/blog/stablecoins-and-other-tokens-demand-stable-fees), [How Hedera calculates the HBAR / USD exchange rate](https://hedera.com/blog/how-hedera-calculates-the-hbar-usd-exchange-rate-for-sdks-and-applications), [Tokenization on Hedera: Tokenomics & Fee Structure](https://docs.hedera.com/hedera/core-concepts/tokens/tokenization-on-hedera#tokenomics-and-fee-structure).


Certainly! Here’s an explanation of each option regarding which key is used to decrypt a message on the network, based on the provided knowledge sources:

---

**A. Public Key**  
The public key is used to encrypt messages or verify digital signatures. It is shared openly and allows anyone to send encrypted messages to the owner of the corresponding private key. However, it cannot be used to decrypt messages.  
[Public Key Glossary](https://docs.hedera.com/hedera/support-and-community/glossary#public-key)

---

**B. Private Key**  
The private key is kept secret by the owner and is used to decrypt messages that were encrypted with the corresponding public key. Only the holder of the private key can decrypt and read the message, ensuring confidentiality. This is a fundamental aspect of asymmetric cryptography used in Hedera and other distributed ledger technologies.  
[Public Key Glossary](https://docs.hedera.com/hedera/support-and-community/glossary#public-key), [Cryptography Glossary](https://docs.hedera.com/hedera/support-and-community/glossary#cryptography-cryptographic)

---

**C. Decryption key**  
While the term "decryption key" is sometimes used generically, in the context of Hedera and asymmetric cryptography, it specifically refers to the private key. The knowledge sources do not use "decryption key" as a formal term.

---

**D. Encryption key**  
The encryption key, in asymmetric cryptography, refers to the public key. It is used to encrypt messages, not to decrypt them.  
[Public Key Glossary](https://docs.hedera.com/hedera/support-and-community/glossary#public-key)

---

**Summary:**  
On the Hedera network, the **private key** (Option B) is used to decrypt messages that have been encrypted with the corresponding public key. The public key is for encryption, and the private key is for decryption.


The correct answer is:  
**A. ECDSA**

The Ethereum Virtual Machine (EVM) uses the Elliptic Curve Digital Signature Algorithm (ECDSA) for signing transactions. Specifically, it uses the secp256k1 curve as the parameter for ECDSA, but the algorithm itself is ECDSA. ED25519 is not used by the EVM for transaction signing.  
You can find this information in the Hedera documentation, which states that EVM accounts are managed using ECDSA (secp256k1) keys, and ECDSA is the cryptographic algorithm used for digital signatures in Ethereum and EVM-compatible networks [Hedera > Support-and-community > Glossary > ECDSA](https://docs.hedera.com/hedera/support-and-community/glossary#e), [Hedera > Core-concepts > Smart-contracts > Understanding Hedera's EVM Differences and Compatibility](https://docs.hedera.com/hedera/core-concepts/smart-contracts/understanding-hederas-evm-differences-and-compatibility).

Certainly! Here’s an expanded explanation of each option regarding which algorithm works with the Ethereum Virtual Machine (EVM):

---

**A. ECDSA**  
ECDSA stands for Elliptic Curve Digital Signature Algorithm. It is the cryptographic algorithm used by the Ethereum Virtual Machine (EVM) for generating and verifying digital signatures. ECDSA is essential for transaction signing and account management in Ethereum and EVM-compatible networks. The EVM relies on ECDSA for its security and integrity, making it the standard algorithm for these environments. Accounts in Ethereum are managed using ECDSA keys, specifically with the secp256k1 curve parameters [Glossary: ECDSA](https://docs.hedera.com/hedera/support-and-community/glossary#e).

---

**B. secp256k1**  
secp256k1 is not a cryptographic algorithm itself, but rather the name of a specific elliptic curve used as a parameter for the ECDSA algorithm. In the context of Ethereum and the EVM, ECDSA is always used with the secp256k1 curve. This combination—ECDSA with secp256k1—provides the cryptographic foundation for Ethereum’s account and transaction model. So, while secp256k1 is crucial, it is the curve used by the ECDSA algorithm, not an algorithm on its own [Glossary: ECDSA secp256k1](https://docs.hedera.com/hedera/support-and-community/glossary#e).

---

**C. ED25519**  
ED25519 is a different digital signature algorithm based on the Edwards-curve Digital Signature Algorithm (EdDSA). It is not used by the Ethereum Virtual Machine. Instead, ED25519 is supported natively by Hedera for account keys and signatures, offering strong security and efficiency. However, the EVM and Ethereum ecosystem do not use ED25519 for transaction signing or account management [Glossary: Ed25519](https://docs.hedera.com/hedera/support-and-community/glossary#e), [MetaMask FAQ](https://docs.hedera.com/hedera/open-source-solutions/hedera-wallet-snap-by-metamask#faqs).

---

**Summary:**  
- **ECDSA** is the algorithm used by the EVM.
- **secp256k1** is the elliptic curve parameter for ECDSA in the EVM.
- **ED25519** is not used by the EVM.

The correct answer is:  
**B. ED25519**

ED25519 is noted for its strong security and efficiency, and it is the native key type for Hedera accounts and services. It is preferred for use cases where key length, security, and performance are important. ED25519 keys are supported natively by Hedera and are compatible with all Hedera native services, including advanced features like multi-signature and threshold keys. In contrast, ECDSA (with the secp256k1 curve) is primarily used for EVM compatibility and Ethereum interoperability, but not natively across all Hedera services [Keys and Signatures](https://docs.hedera.com/hedera/core-concepts/keys-and-signatures), [MetaMask FAQ](https://docs.hedera.com/hedera/open-source-solutions/hedera-wallet-snap-by-metamask#faqs).

A signature **is required** to submit a transaction on Hedera. The knowledge sources clearly state that, at a minimum, the account paying for the transaction fees must sign the transaction as authorization. Additional signatures may be required depending on the properties set for the account, topic, or token. Without the necessary signatures, the transaction will not be processed by the network [Hedera > Core-concepts > Transactions and Queries](https://docs.hedera.com/hedera/core-concepts/transactions-and-queries).

Therefore, the statement "A signature is NOT required to submit a transaction" is **incorrect**.

The correct answer is:  
**E. All of the above**

A transaction submitted to a Hedera network must include:

- **Transaction ID:** Uniquely identifies the transaction and is composed of the payer account ID and the transaction's valid start time [Hedera > Core-concepts > Transactions and Queries](https://docs.hedera.com/hedera/core-concepts/transactions-and-queries).
- **Transaction Valid Duration:** Specifies the period during which the transaction is valid on the network [Hedera > Core-concepts > Transactions and Queries](https://docs.hedera.com/hedera/core-concepts/transactions-and-queries).
- **Signatures:** At a minimum, the payer account must sign the transaction for authorization [Hedera > Core-concepts > Transactions and Queries](https://docs.hedera.com/hedera/core-concepts/transactions-and-queries).
- **Transaction Detail:** The specific operation or body of the transaction, such as a transfer, contract call, or file operation [Hedera > Sdks-and-apis > Hedera-api > Miscellaneous > TransactionBody](https://docs.hedera.com/hedera/sdks-and-apis/hedera-api/miscellaneous/transactionbody).

All these components are required for a valid transaction submission on Hedera.

**A. True**

Hedera natively supports multisignature transactions. This means a Hedera transaction can require more than one key to sign in order for it to be processed on the network. Multisignature support is built into the platform and does not require smart contracts or additional scripting to enforce m-of-n logic. You can configure accounts with key lists or threshold keys, enabling flexible and secure multi-party authorization for transactions [Sign a multisignature transaction](https://docs.hedera.com/hedera/sdks-and-apis/sdks/transactions/sign-a-multisignature-transaction), [Hierarchical Multi-Signature support in Hedera](https://hedera.com/blog/hierarchical-multi-signature-support-in-hedera).

The correct answer is:  
**C. 3**

The valid duration on a Hedera transaction is up to 180 seconds, which is 3 minutes ([Hedera > Core-concepts > Transactions and Queries](https://docs.hedera.com/hedera/core-concepts/transactions-and-queries)).


If a transaction is submitted to the network within the time window specified by the valid start time plus the valid duration, then the transaction will be **accepted** (option B), provided all other requirements (such as signatures and fees) are met. Transactions submitted outside this window will be rejected as expired [Hedera > Core-concepts > Transactions and Queries](https://docs.hedera.com/hedera/core-concepts/transactions-and-queries).

The statement "If the schedule doesn’t receive sufficient signatures within 10 minutes, it’s deleted" is **not correct** according to the knowledge sources. The default expiration time for a scheduled transaction on Hedera is **30 minutes** from creation, not 10 minutes. If the required signatures are not collected within this 30-minute window, the scheduled transaction will expire and be deleted from the network. With recent updates (HIP-423), this expiration time can be set up to 2 months, but the default remains 30 minutes unless otherwise specified [Hedera > Core-concepts > Schedule Transaction](https://docs.hedera.com/hedera/core-concepts/scheduled-transaction#overview), [Announcing Scheduled Transactions on Hedera](https://hedera.com/blog/announcing-scheduled-transactions-on-hedera).

So, a schedule is **not deleted after 10 minutes**—it is deleted after the specified expiration time, which is 30 minutes by default.

The correct answer is:  
**B. scheduleGetInfo**

With the `scheduleGetInfo` method (or `ScheduleGetInfoQuery`), a prospective signer can check the contents of the inner (scheduled) transaction before deciding to sign it. This query returns information about the scheduled transaction, including its transaction body, signatories, admin key, expiration time, and more. This allows a signer to review all relevant details and ensure the transaction is as expected before providing their signature [Get schedule info](https://docs.hedera.com/hedera/sdks-and-apis/sdks/schedule-transaction/get-schedule-info).

---

### Expounding on Each Option

**A. scheduleCreate**  
This method (`ScheduleCreateTransaction`) is used to create a new schedule entity on the Hedera network. It defines the transaction to be scheduled and sets properties like the admin key, payer account, expiration time, and memo. It does not allow a prospective signer to review the inner transaction after creation—only to create it [Create a schedule transaction](https://docs.hedera.com/hedera/sdks-and-apis/sdks/schedule-transaction/create-a-schedule-transaction).

**B. scheduleGetInfo**  
This method (`ScheduleGetInfoQuery`) allows anyone to query the network for information about a scheduled transaction using its schedule ID. The response includes the scheduled transaction body, signatories, admin key, expiration time, and more. This is the method a prospective signer would use to review the transaction before signing [Get schedule info](https://docs.hedera.com/hedera/sdks-and-apis/sdks/schedule-transaction/get-schedule-info).

**C. scheduleSign**  
This method (`ScheduleSignTransaction`) is used to add a signature to an existing scheduled transaction. It does not provide information about the transaction itself; it simply appends the signer's signature to the schedule [Schedule Transaction FAQ](https://docs.hedera.com/hedera/core-concepts/scheduled-transaction#faq).

**D. scheduleDelete**  
This method (`ScheduleDeleteTransaction`) is used to delete a scheduled transaction before it is executed or expires, provided the admin key was set. It does not allow for reviewing the inner transaction contents [Schedule Transaction FAQ](https://docs.hedera.com/hedera/core-concepts/scheduled-transaction#faq).

---

**Summary:**  
A prospective signer should use **scheduleGetInfo** to check the contents of the inner transaction before signing.

The correct answers are:

- **A. scheduledTransactionBody**
- **B. memo**
- **D. payerAccountID**

These fields are all included in the `ScheduleCreate` transaction. The `scheduledTransactionBody` specifies the transaction to be scheduled, `memo` is an optional memo field, and `payerAccountID` is an optional field for specifying the account to be charged the service fee. There is no `newSigner` field in `ScheduleCreate` [ScheduleCreateTransactionBody](https://docs.hedera.com/hedera/sdks-and-apis/hedera-api/schedule-service/schedulecreate), [Scheduled transactions spec](https://github.com/hashgraph/hedera-services/blob/main/hedera-node/docs/scheduled-transactions/revised-spec.md).

**B. False**

Generally, queries on Hedera **are** subject to fees. While certain queries—such as asking for an account balance, a transaction receipt, or the projected cost of a query—are free, most queries require the client to pay a fee to the node that processes and responds to the query. The fee compensates the node for the resources used to process the request. This is clearly stated in the documentation:

> "Certain queries are free, but generally, queries are subject to fees."  
[Hedera > Core-concepts > Transactions and Queries](https://docs.hedera.com/hedera/core-concepts/transactions-and-queries#queries)

So, the statement "Generally, queries are not subject to fees" is **false**.

The correct answer is:  
**B. State proofs**

### Expounding on Each:

**A. Receipts**  
Receipts provide minimal information—simply whether or not the transaction was successfully processed into consensus state, and the identifier of any object created if successful. They are free and exist for a short period (3 minutes). Receipts are suitable for basic confirmation but do not provide detailed information about the transaction or its effects. They can be corrupted by a malicious node, so they offer minimal trust and detail [Hedera > Core-concepts > Transactions and Queries](https://docs.hedera.com/hedera/core-concepts/transactions-and-queries#queries), [Transaction Confirmation Methods in Hedera](https://hedera.com/blog/transaction-confirmation-methods-in-hedera).

**B. State proofs**  
State proofs provide the highest level of detail and trust. When querying for a record, a client can request a state proof, which documents network consensus on the contents of that record. State proofs are cryptographically signed by a supermajority of the network, making them secure and potentially admissible in a court of law. They expose the most information, including the record itself and cryptographic evidence of its validity, offering the strongest confirmation mechanism available on Hedera [Hedera > Core-concepts > Transactions and Queries](https://docs.hedera.com/hedera/core-concepts/transactions-and-queries#queries), [State Proofs on Hedera](https://hedera.com/blog/state-proofs-on-hedera).

**C. Records**  
Records provide more detail than receipts, such as the consensus timestamp, the results of a smart contract function call, and a transfer list showing how balances changed. However, while records are more detailed than receipts, they do not include the cryptographic proof of network consensus that state proofs provide. Records are available for a limited time and require a fee to retrieve [Hedera > Core-concepts > Transactions and Queries](https://docs.hedera.com/hedera/core-concepts/transactions-and-queries#queries), [Transaction Confirmation Methods in Hedera](https://hedera.com/blog/transaction-confirmation-methods-in-hedera).

---

**Summary:**  
State proofs expose the most detail and provide the highest level of trust and confirmation on Hedera.

The **incorrect** answers are:

**C. State is not able to be changed**  
**D. Transaction history is mutable**

### Explanation:

- **State is mutable** (**A**) — This is **correct**. The state in the Hedera Network is mutable; it constantly changes as transactions are applied to it.
- **Transaction history is immutable** (**B**) — This is **correct**. The history of transactions is generally considered immutable and irreversible.
- **State is not able to be changed** (**C**) — This is **incorrect**. The state is, by definition, mutable and changes as new transactions are processed.
- **Transaction history is mutable** (**D**) — This is **incorrect**. Transaction history is considered immutable and is not meant to be changed.

These facts are clearly stated in the Hedera documentation:

> "State is mutable by definition, constantly changing as transactions are applied to it. In contrast, the history of transactions is generally considered immutable and irreversible."  
[Hedera > Core-concepts > State and History](https://docs.hedera.com/hedera/core-concepts/state-and-history#faq)

**Therefore, the incorrect answers are C and D.**

**A. True**

It is important to avoid targeting only one node for submitting transactions, as relying on a single node introduces a single point of failure. If that node is offline, malicious, or delays your transaction, your transaction may not be processed promptly or at all. Hedera documentation recommends submitting transactions to multiple nodes to mitigate this risk. By doing so, even if one node fails or acts maliciously, another honest node can ensure your transaction is submitted and reaches consensus. This approach enhances reliability and fairness in transaction processing on the network [Hedera Blog: Counter FUD](https://hedera.com/blog/counter-fud), [Hedera Consensus Service Whitepaper](https://hedera.com/hh-consensus-service-whitepaper.pdf).

**B  
False.**

The Hedera testnet allows creation of both ED25519 and ECDSA accounts. This is confirmed by the Hedera Portal, which provides options to create testnet accounts with either key type, and by wallet solutions like HashPack, which also support both ED25519 and ECDSA accounts on testnet. SDK documentation and tutorials further demonstrate account creation with both key types on testnet [Create Testnet Accounts with ED25519 and ECDSA Keys from the Hedera Portal](https://hedera.com/blog/create-accounts-with-ed25519-and-ecdsa-keys-from-the-hedera-portal) [Create and Fund Your Hedera Testnet Account](https://docs.hedera.com/hedera/tutorials/more-tutorials/create-and-fund-your-hedera-testnet-account#option-3-hashpack-wallet).

The officially supported languages in the Hedera SDK are:

- **B. Java**
- **D. Go**
- **F. Javascript**

**Explanation:**  
According to the official Hedera documentation and recent blog posts, the Hedera SDKs that are officially supported (maintained by Hedera) are Java, Go, and JavaScript. Swift, Ruby, and Python are not listed as officially supported languages—Python is community-supported, and there is no mention of official support for Swift or Ruby in the provided knowledge sources [SDKs](https://docs.hedera.com/hedera/sdks-and-apis/sdks) [How to develop on Hedera: Back to the Basics](https://hedera.com/blog/how-to-develop-on-hedera-back-to-the-basics).

So, the correct answers are:  
**B. Java**  
**D. Go**  
**F. Javascript**

**A  
True.**

A client may send the same transaction to multiple nodes via the Hedera SDK. This is a recommended approach to protect against a malicious or slow node that might delay or censor a transaction. By submitting the same transaction to multiple nodes, only the first transaction to reach consensus will be processed, and the duplicates will be ignored. This mechanism ensures fair access and order for the client’s transaction [Fair access v fair ordering and transactions per second examined and explained](https://hedera.com/blog/fair-access-v-fair-ordering-and-transactions-per-second-examined-and-explained) [Hedera Consensus Service Whitepaper](https://hedera.com/hh-consensus-service-whitepaper.pdf).

**D  
False, one can also use previewnet and testnet.**

The knowledge sources clearly state that the Hedera SDK allows you to submit transactions and queries not only to mainnet, but also to testnet and previewnet. The SDK provides pre-configured methods for each network, such as `Client.forMainnet()`, `Client.forTestnet()`, and `Client.forPreviewnet()`, enabling developers to interact with all three environments [Build Your Hedera Client](https://docs.hedera.com/hedera/sdks-and-apis/sdks/client#id-1.-configure-your-hedera-network) [Hedera Release Cycle Overview](https://hedera.com/blog/hedera-release-cycle-overview).


The correct answer is:

**A  
AccountCreateTransaction**

**Explanation of each option:**

- **A. AccountCreateTransaction**  
  This is the correct class used by the Hedera SDK to create new accounts. The knowledge sources provide multiple examples of using `AccountCreateTransaction` to build and execute account creation transactions in JavaScript, Java, and Go. This class allows you to set the account key, initial balance, and other properties before submitting the transaction to the network [Create an account using the account create API](https://docs.hedera.com/hedera/sdks-and-apis/sdks/accounts-and-hbar/create-an-account#create-an-account-using-the-account-create-api) [Step 3: Create Your First Account on Hedera](https://docs.hedera.com/hedera/getting-started-hedera-native-developers/create-an-account#step-3-create-your-first-account-on-hedera).

- **B. AccountNewTransaction**  
  There is no mention of a class named `AccountNewTransaction` in the Hedera SDK documentation or knowledge sources.

- **C. AccountBuildTransaction**  
  There is no mention of a class named `AccountBuildTransaction` in the Hedera SDK documentation or knowledge sources.

- **D. AccountUpdateTransaction**  
  This class is used to update properties of an existing account, not to create a new one [Transactions](https://docs.hedera.com/hedera/sdks-and-apis/sdks/transactions).

Therefore, the only correct answer is **A. AccountCreateTransaction**.

**A  
True**

The knowledge sources confirm that the `.env` file is used to store sensitive information such as private keys as environment variables, which is a security improvement over hardcoding them directly into your code. This approach helps protect your credentials and makes it easier to manage different environments. For example, Hedera documentation and tutorials consistently instruct users to store private keys in a `.env` file and load them into the application, rather than embedding them in the code itself [Build Your Hedera Client](https://docs.hedera.com/hedera/sdks-and-apis/sdks/client#from-a-.env-file) [Deploy a Smart Contract Using Hardhat](https://docs.hedera.com/hedera/tutorials/smart-contracts/deploy-a-smart-contract-using-hardhat-hedera-json-rpc-relay#step-2-configure-project).


The best answer is:

**B  
In order to transfer Hbar you must use TransferHbarTransaction()**

**Explanation:**  
The code uses `TransferTransactions()` (plural), which is not a valid class in the Hedera SDK. The correct class to use for transferring HBAR is `TransferTransaction()` (singular). This is clearly shown in the official documentation and examples, where all HBAR transfers are performed using `TransferTransaction()`:

```javascript
const transaction = new TransferTransaction()
    .addHbarTransfer(senderAccount, Hbar.fromTinybars(-1))
    .addHbarTransfer(recipientAccount, Hbar.fromTinybars(1));
```
[Transfer cryptocurrency](https://docs.hedera.com/hedera/sdks-and-apis/sdks/accounts-and-hbar/transfer-cryptocurrency#methods)

The other options are not correct based on the knowledge sources:
- Negative values for HBAR are valid and indicate a debit.
- The order of `addHbarTransfer` calls is not restricted to receiver first.
- While the net value must be zero, the most immediate error in the code provided is the use of the wrong class name.

The best answer is:

**D  
The net value of the transfer should be zero, ensuring that the total HBAR sent by the sender matches the total received by the recipient.**

**Explanation:**  
According to the Hedera documentation, every HBAR transfer transaction must have a net sum of zero between all sending and receiving accounts. This means the total amount debited (negative values) must exactly match the total amount credited (positive values). In your code, you are sending -75 tinybars and receiving 72 tinybars, which sums to -3, not zero. This will cause the transaction to fail with an error such as `INVALID_ACCOUNT_AMOUNTS` because the transfer list does not net to zero. This requirement is explicitly stated in the documentation: "The net value of HBAR between the sending accounts and receiving accounts must equal zero" [Transfer cryptocurrency](https://docs.hedera.com/hedera/sdks-and-apis/sdks/accounts-and-hbar/transfer-cryptocurrency).

The other options are not correct based on the knowledge sources:
- Negative values are valid for debiting accounts.
- The correct class is `TransferTransaction()`, not `TransferHbarTransaction()`.
- The order of `addHbarTransfer` calls is not restricted; each call specifies an account and an amount.

The provided code block does **not** actually query or output the account balance, so there is no denomination shown in the output. However, according to the knowledge sources, when you do query an account balance using the Hedera SDK or Mirror Node API, the balance is returned in **tinybars** by default. This is explicitly stated: "the network returns information in tinybars (tℏ), a denomination of HBAR. 100,000,000 tℏ are equivalent to 1 ℏ" [Core Concepts: Accounts](https://docs.hedera.com/hedera/core-concepts/accounts).

**Best answer:**

**C  
TINYBAR**