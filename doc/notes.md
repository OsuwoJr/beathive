No, Hedera is not a blockchain. Instead, Hedera uses a different form of distributed ledger technology called hashgraph, which is based on a directed acyclic graph (DAG) structure. Unlike blockchains, which organize data into sequential blocks, hashgraph weaves all events together without discarding any, resulting in higher efficiency, speed, and security. This approach allows Hedera to process transactions more quickly and with lower fees than traditional blockchains, while also being more energy-efficient [Hedera Defined & Explained](https://hedera.com/learning/hedera-hashgraph/what-is-hedera-hashgraph?) [Blockchain and Edge Computing: A Powerful Data Duo](https://hedera.com/learning/data/blockchain-and-edge-computing) [DAG vs Blockchain: A Look at the Pluses and Minuses](https://hedera.com/learning/distributed-ledger-technologies/dag-vs-blockchain).

..........................................................................................
Hedera has several distinctive qualities, as described in the knowledge sources:

- **Not a Blockchain**: Hedera uses the hashgraph consensus algorithm, which is a directed acyclic graph (DAG) rather than a traditional blockchain structure. This allows for higher efficiency and throughput [Hedera Defined & Explained](https://hedera.com/learning/hedera-hashgraph/what-is-hedera-hashgraph?).

- **Performance**: Capable of processing hundreds of thousands of transactions per second in a single shard, with consensus latency measured in seconds, not minutes or hours [Hedera: A Public Hashgraph Network & Governing Council](https://files.hedera.com/hh_whitepaper_v2.2-20230918.pdf).

- **Security**: Achieves asynchronous Byzantine Fault Tolerance (aBFT), the gold standard for security in distributed systems, and is resistant to Distributed Denial of Service (DDoS) attacks [What are distributed ledger technologies (DLTs)?](https://hedera.com/learning/distributed-ledger-technologies/what-are-distributed-ledger-technologies-dlts?) [Hedera: A Public Hashgraph Network & Governing Council](https://files.hedera.com/hh_whitepaper_v2.2-20230918.pdf).

- **Fairness**: Ensures fairness in the order of transactions, preventing individuals or small groups from manipulating transaction order. There is no concept of leaders or miners who can prioritize transactions for higher fees [Hedera Consensus Service Whitepaper](https://hedera.com/hh-consensus-service-whitepaper.pdf).

- **Energy Efficiency**: Does not require energy-intensive mining, making it much more energy-efficient and inexpensive to operate compared to proof-of-work blockchains [What is hashgraph consensus?](https://hedera.com/learning/hedera-hashgraph/what-is-hashgraph-consensus).

- **Predictable and Low Fees**: Transaction fees are predictable and not subject to bidding wars or congestion pricing [Blockchain Transactions: A Behind-the-Scenes Look](https://hedera.com/learning/distributed-ledger-technologies/blockchain-transactions).

- **Decentralized Governance**: Governed by the Hedera Governing Council, a rotating group of leading global organizations from diverse industries and geographies, each with equal voting rights and term limits to ensure decentralization [Hedera Defined & Explained](https://hedera.com/learning/hedera-hashgraph/what-is-hedera-hashgraph?).

- **No Forking**: The governance and licensing model is designed to eliminate the risk of forking, protecting the integrity of the codebase [Hedera: A Public Hashgraph Network & Governing Council](https://files.hedera.com/hh_whitepaper_v2.2-20230918.pdf).

- **Open Source**: Both the hashgraph algorithm and Hedera’s implementation are open sourced under an Apache 2.0 license [Hedera Defined & Explained](https://hedera.com/learning/hedera-hashgraph/what-is-hedera-hashgraph?).

- **Tamper-Apparent**: Any tampering with the ledger is apparent to all network participants, ensuring transparency [What are distributed ledger technologies (DLTs)?](https://hedera.com/learning/distributed-ledger-technologies/what-are-distributed-ledger-technologies-dlts?).

- **Multiple Services**: Offers smart contracts, consensus, and token services for building decentralized applications [Hedera Defined & Explained](https://hedera.com/learning/hedera-hashgraph/what-is-hedera-hashgraph?).

If you need more specific qualities or details, please clarify your request!


...............................................................................
The main objective of the Hedera Governing Council is to provide decentralized, stable, and effective governance for the Hedera network. The Council is responsible for overseeing key aspects such as software upgrades, network pricing, treasury management, and regulatory compliance. Its structure—composed of up to 39 leading global organizations from diverse industries and geographies, each with equal voting rights and term limits—ensures that no single entity or group can dominate decision-making. This governance model is designed to maintain the long-term interests, stability, and decentralization of the Hedera network, while eliminating risks like forks and safeguarding the integrity of the platform [Hedera Defined & Explained](https://hedera.com/learning/hedera-hashgraph/what-is-hedera-hashgraph) [HH Hbar Economics Whitepaper](https://hedera.com/hh-hbar-coin-economics-paper-060320-v6.pdf) [Hedera: A Public Hashgraph Network & Governing Council](https://files.hedera.com/hh_whitepaper_v2.2-20230918.pdf).


.................................................................................
The areas of responsibility of the Hedera Governing Council, as described in the knowledge sources, include:

- **Participating in the governance of the Hedera network**: This involves making decisions on software updates, network rules, and the overall direction of the platform.
- **Hosting and maintaining nodes**: Council members are responsible for running the initial nodes of the Hedera network.
- **Treasury management**: Overseeing the management and security of the Hedera Treasury, including the control and distribution of HBAR tokens.
- **Network pricing**: Setting and approving network transaction fees and pricing models.
- **Regulatory compliance**: Advising and ensuring the network adheres to relevant legal and regulatory requirements.
- **Oversight of software development**: Guiding the technical roadmap and approving changes to the platform codebase.
- **Committee participation**: Council members serve on various committees, such as finance, technical steering, membership, legal & regulatory, and marketing, to address specific aspects of network governance.
- **Ensuring decentralization and stability**: The Council is structured to prevent any single entity or group from gaining control, thus maintaining the network’s decentralization and long-term stability.

These responsibilities are designed to ensure the effective, decentralized, and transparent governance of the Hedera network [HH Hbar Economics Whitepaper](https://hedera.com/hh-hbar-coin-economics-paper-060320-v6.pdf) [Hedera Defined & Explained](https://hedera.com/learning/hedera-hashgraph/what-is-hedera-hashgraph) [Hedera Hashgraph Governing Council Names Brett McDowell as Executive Director and Vice Chair, Establishes Council Committees](https://hedera.com/blog/hedera-hashgraph-governing-council-names-brett-mcdowell-as-executive-director-and-vice-chair-establishes-council-committees) [DLA Piper: The future of public distributed ledgers in law and why we joined the Hedera Governing Council](https://hedera.com/blog/dla-piper-the-future-of-public-distributed-ledgers-in-law-and-why-we-joined-the-hedera-governing-council).

...............................................................................

Here are features that are **not typical of web2 software development but are features of Hedera**:

- **Decentralized, pseudonymous accounts**: Hedera accounts are identified by pseudonymous IDs (e.g., 0.0.1234) and controlled by cryptographic keys, removing the need for personal metadata like email and password, which are common in web2 [PROTECTION ON HEDERA > DATA ON HEDERA](https://hedera.com/HH_Web-3-Privacy-Architecture_20211111.pdf).

- **Consensus via hashgraph algorithm**: Hedera uses the hashgraph consensus algorithm, providing high throughput, fairness in transaction ordering, and asynchronous Byzantine Fault Tolerance (aBFT)—features not present in web2 systems [Hedera: A Public Hashgraph Network & Governing Council](https://files.hedera.com/hh_whitepaper_v2.2-20230918.pdf).

- **Immutable, distributed ledger**: Data and transactions are stored immutably across a distributed network, rather than in centralized databases as in web2 [PROTECTION ON HEDERA > BUILDING PRIVACY INTO DAPPS](https://hedera.com/HH_Web-3-Privacy-Architecture_20211111.pdf).

- **User-controlled privacy and non-custodial models**: In Hedera, users can interact directly with the network using their own keys, without relying on centralized intermediaries, enabling privacy-centric, non-custodial applications [PROTECTION ON HEDERA > BUILDING PRIVACY INTO DAPPS](https://hedera.com/HH_Web-3-Privacy-Architecture_20211111.pdf).

- **Decentralized governance**: The Hedera Governing Council, composed of global organizations with equal voting rights and term limits, governs the network—unlike the centralized control typical in web2 platforms [Hedera: A Public Hashgraph Network & Governing Council](https://files.hedera.com/hh_whitepaper_v2.2-20230918.pdf).

- **Open, tamper-apparent data**: All transactions and changes are visible and verifiable by anyone, ensuring transparency and auditability, which is not a default feature in web2 [PROTECTION ON HEDERA > DATA ON HEDERA](https://hedera.com/HH_Web-3-Privacy-Architecture_20211111.pdf).

These features distinguish Hedera and web3 development from traditional web2 software development.

....................................................................................
The phase of network growth that includes **permissionless nodes** is **Phase 3**. In this phase, any person or organization will be able to run a Hedera mainnet consensus node with anonymity, and node operators receive hbars for contributing to consensus and providing services [HH Decentralization of Consensus Whitepaper](https://files.hedera.com/hh-decentralization-of-consensus.pdf).

............................................................................

The characteristic that describes the **future state of node operation on the Hedera network** is **Public Permissionless**. In this state, anyone can run a node anonymously and participate in network consensus, which is the most decentralized form of distributed ledger technology [Hedera Defined & Explained](https://hedera.com/learning/hedera-hashgraph/what-is-hedera-hashgraph?) [HH Decentralization of Consensus Whitepaper](https://files.hedera.com/hh-decentralization-of-consensus.pdf).


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Today, Hedera is best described as **Public Permissioned**. This means anyone can use the network to create accounts and deploy applications, but only invited and approved entities (the Hedera Governing Council members) can operate consensus nodes [Hedera Defined & Explained](https://hedera.com/learning/hedera-hashgraph/what-is-hedera-hashgraph?) [HH Decentralization of Consensus Whitepaper](https://files.hedera.com/hh-decentralization-of-consensus.pdf).

............................................................................
Yes, blockchains are a form of distributed ledger technology (DLT). Distributed ledger technologies are peer-to-peer networks that enable multiple members to maintain their own identical copy of a shared ledger, and blockchain is one type of DLT where data is stored in blocks that are linked together in order of creation [What are distributed ledger technologies (DLTs)?](https://hedera.com/learning/distributed-ledger-technologies/what-are-distributed-ledger-technologies-dlts?) [Blockchain and Digital Transformation](https://hedera.com/learning/distributed-ledger-technologies/digital-transformation).
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

The correct answer is **Mainnet**.

Mainnet is the production Hedera network where real-value transactions occur, and transaction fees are paid in real HBAR. This is where applications are run in production, and users interact with the network in a live environment with actual costs. In contrast, Previewnet and Testnet are for development and testing, and the Local Network is for local development only, without real-value transactions or costs [Mainnet Overview](https://docs.hedera.com/hedera/networks/mainnet) [Hedera Release Cycle Overview](https://hedera.com/blog/hedera-release-cycle-overview).

The correct answer is **Previewnet**.

Previewnet is described as a network where "accounts / data are likely to be lost when the network codebase is upgraded" because it runs a codebase still under development, and stability is not guaranteed [The Hedera previewnet is now live](https://hedera.com/blog/the-hedera-previewnet-is-now-live).


The correct answer is **Mirror node**.

Mirror nodes on Hedera are specifically designed to provide analytical insight into an application’s state and transactions. They store and make available historical and real-time ledger information, enabling queries, analytics, audit support, and monitoring without impacting the performance of consensus nodes [What is the Hedera mirror network?](https://hedera.com/learning/hedera-hashgraph/what-is-the-hedera-mirror-network?) [Understanding Mirror Nodes](https://docs.hedera.com/hedera/core-concepts/mirror-nodes#understanding-mirror-nodes).


The characteristics of Consensus Nodes, based on the provided knowledge sources, are:

- **A: Can submit HAPI (Hedera API) transactions to the Hedera network**
- **C: Requires HBAR cryptocurrency payment for transactions & queries**

**Explanation:**
- Consensus nodes can submit HAPI transactions to the Hedera network and require HBAR payment for processing transactions and queries [What is the Hedera mirror network?](https://hedera.com/learning/hedera-hashgraph/what-is-the-hedera-mirror-network?).
- Maintaining a history of the ledger (B) and publish/subscribe capabilities (D) are characteristics of mirror nodes, not consensus nodes.

So, the correct choices are **A** and **C**.


The Hedera network services, according to the provided knowledge sources, are:

- **A. Hedera Token Service**
- **B. Hedera Smart Contract Service**
- **D. Hedera Consensus Service**

There is no mention of a "Hedera Token Contract Service" as a network service in the knowledge sources. The official services are Token Service, Smart Contract Service, and Consensus Service [Hedera Network Services](https://docs.hedera.com/hedera#hedera-network-services) [Services Overview](https://github.com/hashgraph/hedera-services/blob/main/hedera-node/docs/design/services/services.md).

The correct answer is:

**D. True for Hedera Mirror Node Rest API**

You can look up transaction history and filter by account, balance, transaction, topic, token, NFT, smart contract, and more using the Hedera Mirror Node REST API. This is explicitly described in the knowledge sources, which state that the Mirror Node REST API enables you to query transactions and account information, and filter by various criteria such as account, balance, transaction, topic, token, NFT, and smart contract [How to Use Mirror Nodes?](https://hedera.com/blog/how-to-look-up-transaction-history-on-hedera-using-mirror-nodes-back-to-the-basics) [Mirror Node REST API](https://docs.hedera.com/hedera/sdks-and-apis/rest-api).

The other options are incorrect:
- Consensus nodes do not provide this level of historical query and filtering.
- The statement is not false for the Mirror Node REST API; it is true.
- There is no "Hedera Consensus Node Rest API" for this purpose.

The correct answer is **B. Hedera File Service**.

The Hedera File Service is used for decentralized file storage and is often used in conjunction with other services to store data such as smart contract bytecode or token metadata. It is specifically mentioned as being used for "smart contract storage" among other use cases [Hedera File Service](https://github.com/hashgraph/hedera-services/blob/main/hedera-node/docs/design/services/services.md).


The correct answer is **B. Hedera File Service**.

The Hedera File Service is used for decentralized file storage and is often used in conjunction with other services to store data such as smart contract bytecode or token metadata. It is specifically mentioned as being used for "smart contract storage" among other use cases [Hedera File Service](https://github.com/hashgraph/hedera-services/blob/main/hedera-node/docs/design/services/services.md).

The use cases of the Hedera Consensus Service, according to the knowledge sources, are:

- **A. Event ordering**  
- **B. Integrity Check**  
- **D. Timestamping**  

**Event ordering** and **timestamping** are core features of HCS, providing decentralized, fair, and verifiable ordering of events with trusted timestamps [Hedera Consensus Service](https://hedera.com/learning/hedera-hashgraph/what-is-hedera-hashgraph) [Consensus Service Design](https://github.com/hashgraph/hedera-services/blob/main/hedera-node/docs/design/services/consensus-service/consensus-service.md).  
**Integrity check** is enabled by submitting hashes of data to HCS, allowing verification that data has not been tampered with [Data Timestamping for Data Integrity](https://hedera.com/blog/pragmatic-blockchain-design-patterns-integrating-blockchain-into-business-processes).

There is no explicit mention of **de-duplication** as a use case for HCS in the provided knowledge sources.

HTS stands for **Hedera Token Service** [Hedera Token Service (HTS) Native Tokenization](https://docs.hedera.com/hedera/core-concepts/tokens/hedera-token-service-hts-native-tokenization) [Glossary: Hedera Token Service (HTS)](https://docs.hedera.com/hedera/support-and-community/glossary#hedera-token-service-hts).

A. True

It is possible to use the Hedera Token Service (HTS) without prior Solidity or smart contract programming capabilities. HTS allows you to configure, mint, and manage tokens directly using Hedera’s APIs and SDKs, without the need to set up or deploy a smart contract Hedera Token Service - Part 1: How to Mint NFTs Glossary: Hedera Token Service (HTS).

**A. True**

The Hedera Smart Contract Service can be used to build auctions and bridges. It allows developers to deploy and interact with smart contracts on the Hedera network, enabling decentralized applications (dApps) with complex logic and automated processes, such as auctions and interoperability bridges [Services Overview](https://github.com/hashgraph/hedera-services/blob/main/hedera-node/docs/design/services/services.md).

HBAR is the native, utility token of the Hedera network. Its primary utilities are:

- **Transaction Fees:** HBAR is used to pay for transaction and query fees across all Hedera network services, including cryptocurrency transfers, smart contracts, token creation, consensus, and file storage. All fees are paid in HBAR (or its smallest unit, tinybar), making it essential for any activity on the network [Hedera > Core-concepts > Accounts](https://docs.hedera.com/hedera/core-concepts/accounts).

- **Network Security & Staking:** HBAR is staked to nodes to secure the network through Hedera’s proof-of-stake consensus. The amount of HBAR staked to a node determines its influence on consensus, helping to protect against attacks and ensuring network integrity. HBAR holders can also proxy-stake their tokens to nodes and earn rewards for contributing to network security [Hedera > Core-concepts > Staking](https://docs.hedera.com/hedera/core-concepts/staking), [HH Hbar Economics Whitepaper](https://hedera.com/hh-hbar-coin-economics-paper-060320-v6.pdf).

- **Node and Staking Rewards:** HBAR is used to reward node operators for providing computing resources and, through proxy staking, to reward HBAR holders who delegate their tokens to nodes [HH Hbar Economics Whitepaper](https://hedera.com/hh-hbar-coin-economics-paper-060320-v6.pdf).

- **Micropayments:** HBAR enables fast, low-cost micropayments, making it suitable for use cases like pay-per-use content, streaming, and other microtransaction-based applications. Real-world examples include platforms like Dropp and Tune.fm, which use HBAR for instant, direct payments [Hedera Blog: Micropayment Platform Dropp](https://hedera.com/blog/micropayment-platform-dropp-debuts-putting-pay-as-you-go-option-in-reach-of-both-merchants-and-consumers), [Hedera Blog: The Tune.fm JAM Token](https://hedera.com/blog/the-tune-fm-jam-token-journey-to-the-hedera-token-service).

- **Fuel for Decentralized Applications:** HBAR is required to deploy and interact with decentralized applications (dApps) on Hedera, serving as the “fuel” for the network [Learning Article: What is Hedera Hashgraph?](https://hedera.com/learning/hedera-hashgraph/what-is-hedera-hashgraph).

In summary, HBAR is essential for paying network fees, securing the network through staking, rewarding participants, and enabling a wide range of decentralized applications and micropayment use cases on Hedera.

Certainly! Here’s an explanation of each of the three types of fees that make up the Hedera transaction fee:

---

### 1. **Node Fee**
The **Node Fee** compensates the individual node that receives and submits your transaction to the network. When a user or application sends a transaction, it is first sent to a single node. This node expends resources (such as CPU and bandwidth) to process and forward the transaction. The Node Fee is paid directly from the end user’s account to the account of the node that submits the transaction. This incentivizes nodes to participate in the network and handle user requests efficiently.  
[HH Hbar Economics Whitepaper](https://hedera.com/hh-hbar-coin-economics-paper-060320-v6.pdf), [Payments and fees Part 1](https://files.hedera.com/hh_whitepaper_v2.2-20230918.pdf)

---

### 2. **Network Fee**
The **Network Fee** compensates all participating nodes for the work involved in gossiping the transaction, validating digital signatures, and reaching consensus. After the initial node submits the transaction, it is communicated to other nodes, which temporarily store it and participate in consensus. The Network Fee is paid into a Hedera Treasury account, and a portion of these collected fees is distributed daily to nodes as rewards for their participation in consensus.  
[HH Hbar Economics Whitepaper](https://hedera.com/hh-hbar-coin-economics-paper-060320-v6.pdf), [Payments and fees Part 1](https://files.hedera.com/hh_whitepaper_v2.2-20230918.pdf)

---

### 3. **Service Fee**
The **Service Fee** compensates the network for the specific service requested by the transaction, such as transferring cryptocurrency, executing a smart contract, storing a file, or submitting a message. The amount of the Service Fee depends on the resources consumed (e.g., storage size, computation required, or duration of storage). Service Fees are paid by users into a Hedera Treasury account, and a portion is distributed to nodes as rewards.  
[Payments and fees Part 2](https://files.hedera.com/hh_whitepaper_v2.2-20230918.pdf), [HH Hbar Economics Whitepaper](https://hedera.com/hh-hbar-coin-economics-paper-060320-v6.pdf)

---

**Summary Table:**

| Fee Type    | Purpose                                                      | Recipient                |
|-------------|--------------------------------------------------------------|--------------------------|
| Node Fee    | Compensates submitting node for processing the transaction   | Submitting node account  |
| Network Fee | Compensates all nodes for consensus and validation work      | Hedera Treasury account  |
| Service Fee | Compensates for the specific service requested (e.g., storage, smart contract execution) | Hedera Treasury account  |

If you need more technical details or examples, let me know!

Yes, fees on Hedera are based on the United States Dollar (USD). All transaction and query fees are fixed in USD, but they are paid in HBAR. The network regularly updates the exchange rate between USD and HBAR to ensure that the USD value of fees remains stable, even as the price of HBAR fluctuates. This approach provides predictable and stable costs for users and developers on the network [Hedera Stable fees](https://hedera.com/blog/stablecoins-and-other-tokens-demand-stable-fees), [How Hedera calculates the HBAR / USD exchange rate](https://hedera.com/blog/how-hedera-calculates-the-hbar-usd-exchange-rate-for-sdks-and-applications), [Tokenization on Hedera: Tokenomics & Fee Structure](https://docs.hedera.com/hedera/core-concepts/tokens/tokenization-on-hedera#tokenomics-and-fee-structure).


Certainly! Here’s an explanation of each option regarding which key is used to decrypt a message on the network, based on the provided knowledge sources:

---

**A. Public Key**  
The public key is used to encrypt messages or verify digital signatures. It is shared openly and allows anyone to send encrypted messages to the owner of the corresponding private key. However, it cannot be used to decrypt messages.  
[Public Key Glossary](https://docs.hedera.com/hedera/support-and-community/glossary#public-key)

---

**B. Private Key**  
The private key is kept secret by the owner and is used to decrypt messages that were encrypted with the corresponding public key. Only the holder of the private key can decrypt and read the message, ensuring confidentiality. This is a fundamental aspect of asymmetric cryptography used in Hedera and other distributed ledger technologies.  
[Public Key Glossary](https://docs.hedera.com/hedera/support-and-community/glossary#public-key), [Cryptography Glossary](https://docs.hedera.com/hedera/support-and-community/glossary#cryptography-cryptographic)

---

**C. Decryption key**  
While the term "decryption key" is sometimes used generically, in the context of Hedera and asymmetric cryptography, it specifically refers to the private key. The knowledge sources do not use "decryption key" as a formal term.

---

**D. Encryption key**  
The encryption key, in asymmetric cryptography, refers to the public key. It is used to encrypt messages, not to decrypt them.  
[Public Key Glossary](https://docs.hedera.com/hedera/support-and-community/glossary#public-key)

---

**Summary:**  
On the Hedera network, the **private key** (Option B) is used to decrypt messages that have been encrypted with the corresponding public key. The public key is for encryption, and the private key is for decryption.


The correct answer is:  
**A. ECDSA**

The Ethereum Virtual Machine (EVM) uses the Elliptic Curve Digital Signature Algorithm (ECDSA) for signing transactions. Specifically, it uses the secp256k1 curve as the parameter for ECDSA, but the algorithm itself is ECDSA. ED25519 is not used by the EVM for transaction signing.  
You can find this information in the Hedera documentation, which states that EVM accounts are managed using ECDSA (secp256k1) keys, and ECDSA is the cryptographic algorithm used for digital signatures in Ethereum and EVM-compatible networks [Hedera > Support-and-community > Glossary > ECDSA](https://docs.hedera.com/hedera/support-and-community/glossary#e), [Hedera > Core-concepts > Smart-contracts > Understanding Hedera's EVM Differences and Compatibility](https://docs.hedera.com/hedera/core-concepts/smart-contracts/understanding-hederas-evm-differences-and-compatibility).

Certainly! Here’s an expanded explanation of each option regarding which algorithm works with the Ethereum Virtual Machine (EVM):

---

**A. ECDSA**  
ECDSA stands for Elliptic Curve Digital Signature Algorithm. It is the cryptographic algorithm used by the Ethereum Virtual Machine (EVM) for generating and verifying digital signatures. ECDSA is essential for transaction signing and account management in Ethereum and EVM-compatible networks. The EVM relies on ECDSA for its security and integrity, making it the standard algorithm for these environments. Accounts in Ethereum are managed using ECDSA keys, specifically with the secp256k1 curve parameters [Glossary: ECDSA](https://docs.hedera.com/hedera/support-and-community/glossary#e).

---

**B. secp256k1**  
secp256k1 is not a cryptographic algorithm itself, but rather the name of a specific elliptic curve used as a parameter for the ECDSA algorithm. In the context of Ethereum and the EVM, ECDSA is always used with the secp256k1 curve. This combination—ECDSA with secp256k1—provides the cryptographic foundation for Ethereum’s account and transaction model. So, while secp256k1 is crucial, it is the curve used by the ECDSA algorithm, not an algorithm on its own [Glossary: ECDSA secp256k1](https://docs.hedera.com/hedera/support-and-community/glossary#e).

---

**C. ED25519**  
ED25519 is a different digital signature algorithm based on the Edwards-curve Digital Signature Algorithm (EdDSA). It is not used by the Ethereum Virtual Machine. Instead, ED25519 is supported natively by Hedera for account keys and signatures, offering strong security and efficiency. However, the EVM and Ethereum ecosystem do not use ED25519 for transaction signing or account management [Glossary: Ed25519](https://docs.hedera.com/hedera/support-and-community/glossary#e), [MetaMask FAQ](https://docs.hedera.com/hedera/open-source-solutions/hedera-wallet-snap-by-metamask#faqs).

---

**Summary:**  
- **ECDSA** is the algorithm used by the EVM.
- **secp256k1** is the elliptic curve parameter for ECDSA in the EVM.
- **ED25519** is not used by the EVM.

The correct answer is:  
**B. ED25519**

ED25519 is noted for its strong security and efficiency, and it is the native key type for Hedera accounts and services. It is preferred for use cases where key length, security, and performance are important. ED25519 keys are supported natively by Hedera and are compatible with all Hedera native services, including advanced features like multi-signature and threshold keys. In contrast, ECDSA (with the secp256k1 curve) is primarily used for EVM compatibility and Ethereum interoperability, but not natively across all Hedera services [Keys and Signatures](https://docs.hedera.com/hedera/core-concepts/keys-and-signatures), [MetaMask FAQ](https://docs.hedera.com/hedera/open-source-solutions/hedera-wallet-snap-by-metamask#faqs).

A signature **is required** to submit a transaction on Hedera. The knowledge sources clearly state that, at a minimum, the account paying for the transaction fees must sign the transaction as authorization. Additional signatures may be required depending on the properties set for the account, topic, or token. Without the necessary signatures, the transaction will not be processed by the network [Hedera > Core-concepts > Transactions and Queries](https://docs.hedera.com/hedera/core-concepts/transactions-and-queries).

Therefore, the statement "A signature is NOT required to submit a transaction" is **incorrect**.

The correct answer is:  
**E. All of the above**

A transaction submitted to a Hedera network must include:

- **Transaction ID:** Uniquely identifies the transaction and is composed of the payer account ID and the transaction's valid start time [Hedera > Core-concepts > Transactions and Queries](https://docs.hedera.com/hedera/core-concepts/transactions-and-queries).
- **Transaction Valid Duration:** Specifies the period during which the transaction is valid on the network [Hedera > Core-concepts > Transactions and Queries](https://docs.hedera.com/hedera/core-concepts/transactions-and-queries).
- **Signatures:** At a minimum, the payer account must sign the transaction for authorization [Hedera > Core-concepts > Transactions and Queries](https://docs.hedera.com/hedera/core-concepts/transactions-and-queries).
- **Transaction Detail:** The specific operation or body of the transaction, such as a transfer, contract call, or file operation [Hedera > Sdks-and-apis > Hedera-api > Miscellaneous > TransactionBody](https://docs.hedera.com/hedera/sdks-and-apis/hedera-api/miscellaneous/transactionbody).

All these components are required for a valid transaction submission on Hedera.

**A. True**

Hedera natively supports multisignature transactions. This means a Hedera transaction can require more than one key to sign in order for it to be processed on the network. Multisignature support is built into the platform and does not require smart contracts or additional scripting to enforce m-of-n logic. You can configure accounts with key lists or threshold keys, enabling flexible and secure multi-party authorization for transactions [Sign a multisignature transaction](https://docs.hedera.com/hedera/sdks-and-apis/sdks/transactions/sign-a-multisignature-transaction), [Hierarchical Multi-Signature support in Hedera](https://hedera.com/blog/hierarchical-multi-signature-support-in-hedera).

The correct answer is:  
**C. 3**

The valid duration on a Hedera transaction is up to 180 seconds, which is 3 minutes ([Hedera > Core-concepts > Transactions and Queries](https://docs.hedera.com/hedera/core-concepts/transactions-and-queries)).


If a transaction is submitted to the network within the time window specified by the valid start time plus the valid duration, then the transaction will be **accepted** (option B), provided all other requirements (such as signatures and fees) are met. Transactions submitted outside this window will be rejected as expired [Hedera > Core-concepts > Transactions and Queries](https://docs.hedera.com/hedera/core-concepts/transactions-and-queries).

The statement "If the schedule doesn’t receive sufficient signatures within 10 minutes, it’s deleted" is **not correct** according to the knowledge sources. The default expiration time for a scheduled transaction on Hedera is **30 minutes** from creation, not 10 minutes. If the required signatures are not collected within this 30-minute window, the scheduled transaction will expire and be deleted from the network. With recent updates (HIP-423), this expiration time can be set up to 2 months, but the default remains 30 minutes unless otherwise specified [Hedera > Core-concepts > Schedule Transaction](https://docs.hedera.com/hedera/core-concepts/scheduled-transaction#overview), [Announcing Scheduled Transactions on Hedera](https://hedera.com/blog/announcing-scheduled-transactions-on-hedera).

So, a schedule is **not deleted after 10 minutes**—it is deleted after the specified expiration time, which is 30 minutes by default.

The correct answer is:  
**B. scheduleGetInfo**

With the `scheduleGetInfo` method (or `ScheduleGetInfoQuery`), a prospective signer can check the contents of the inner (scheduled) transaction before deciding to sign it. This query returns information about the scheduled transaction, including its transaction body, signatories, admin key, expiration time, and more. This allows a signer to review all relevant details and ensure the transaction is as expected before providing their signature [Get schedule info](https://docs.hedera.com/hedera/sdks-and-apis/sdks/schedule-transaction/get-schedule-info).

---

### Expounding on Each Option

**A. scheduleCreate**  
This method (`ScheduleCreateTransaction`) is used to create a new schedule entity on the Hedera network. It defines the transaction to be scheduled and sets properties like the admin key, payer account, expiration time, and memo. It does not allow a prospective signer to review the inner transaction after creation—only to create it [Create a schedule transaction](https://docs.hedera.com/hedera/sdks-and-apis/sdks/schedule-transaction/create-a-schedule-transaction).

**B. scheduleGetInfo**  
This method (`ScheduleGetInfoQuery`) allows anyone to query the network for information about a scheduled transaction using its schedule ID. The response includes the scheduled transaction body, signatories, admin key, expiration time, and more. This is the method a prospective signer would use to review the transaction before signing [Get schedule info](https://docs.hedera.com/hedera/sdks-and-apis/sdks/schedule-transaction/get-schedule-info).

**C. scheduleSign**  
This method (`ScheduleSignTransaction`) is used to add a signature to an existing scheduled transaction. It does not provide information about the transaction itself; it simply appends the signer's signature to the schedule [Schedule Transaction FAQ](https://docs.hedera.com/hedera/core-concepts/scheduled-transaction#faq).

**D. scheduleDelete**  
This method (`ScheduleDeleteTransaction`) is used to delete a scheduled transaction before it is executed or expires, provided the admin key was set. It does not allow for reviewing the inner transaction contents [Schedule Transaction FAQ](https://docs.hedera.com/hedera/core-concepts/scheduled-transaction#faq).

---

**Summary:**  
A prospective signer should use **scheduleGetInfo** to check the contents of the inner transaction before signing.

The correct answers are:

- **A. scheduledTransactionBody**
- **B. memo**
- **D. payerAccountID**

These fields are all included in the `ScheduleCreate` transaction. The `scheduledTransactionBody` specifies the transaction to be scheduled, `memo` is an optional memo field, and `payerAccountID` is an optional field for specifying the account to be charged the service fee. There is no `newSigner` field in `ScheduleCreate` [ScheduleCreateTransactionBody](https://docs.hedera.com/hedera/sdks-and-apis/hedera-api/schedule-service/schedulecreate), [Scheduled transactions spec](https://github.com/hashgraph/hedera-services/blob/main/hedera-node/docs/scheduled-transactions/revised-spec.md).

**B. False**

Generally, queries on Hedera **are** subject to fees. While certain queries—such as asking for an account balance, a transaction receipt, or the projected cost of a query—are free, most queries require the client to pay a fee to the node that processes and responds to the query. The fee compensates the node for the resources used to process the request. This is clearly stated in the documentation:

> "Certain queries are free, but generally, queries are subject to fees."  
[Hedera > Core-concepts > Transactions and Queries](https://docs.hedera.com/hedera/core-concepts/transactions-and-queries#queries)

So, the statement "Generally, queries are not subject to fees" is **false**.

The correct answer is:  
**B. State proofs**

### Expounding on Each:

**A. Receipts**  
Receipts provide minimal information—simply whether or not the transaction was successfully processed into consensus state, and the identifier of any object created if successful. They are free and exist for a short period (3 minutes). Receipts are suitable for basic confirmation but do not provide detailed information about the transaction or its effects. They can be corrupted by a malicious node, so they offer minimal trust and detail [Hedera > Core-concepts > Transactions and Queries](https://docs.hedera.com/hedera/core-concepts/transactions-and-queries#queries), [Transaction Confirmation Methods in Hedera](https://hedera.com/blog/transaction-confirmation-methods-in-hedera).

**B. State proofs**  
State proofs provide the highest level of detail and trust. When querying for a record, a client can request a state proof, which documents network consensus on the contents of that record. State proofs are cryptographically signed by a supermajority of the network, making them secure and potentially admissible in a court of law. They expose the most information, including the record itself and cryptographic evidence of its validity, offering the strongest confirmation mechanism available on Hedera [Hedera > Core-concepts > Transactions and Queries](https://docs.hedera.com/hedera/core-concepts/transactions-and-queries#queries), [State Proofs on Hedera](https://hedera.com/blog/state-proofs-on-hedera).

**C. Records**  
Records provide more detail than receipts, such as the consensus timestamp, the results of a smart contract function call, and a transfer list showing how balances changed. However, while records are more detailed than receipts, they do not include the cryptographic proof of network consensus that state proofs provide. Records are available for a limited time and require a fee to retrieve [Hedera > Core-concepts > Transactions and Queries](https://docs.hedera.com/hedera/core-concepts/transactions-and-queries#queries), [Transaction Confirmation Methods in Hedera](https://hedera.com/blog/transaction-confirmation-methods-in-hedera).

---

**Summary:**  
State proofs expose the most detail and provide the highest level of trust and confirmation on Hedera.

The **incorrect** answers are:

**C. State is not able to be changed**  
**D. Transaction history is mutable**

### Explanation:

- **State is mutable** (**A**) — This is **correct**. The state in the Hedera Network is mutable; it constantly changes as transactions are applied to it.
- **Transaction history is immutable** (**B**) — This is **correct**. The history of transactions is generally considered immutable and irreversible.
- **State is not able to be changed** (**C**) — This is **incorrect**. The state is, by definition, mutable and changes as new transactions are processed.
- **Transaction history is mutable** (**D**) — This is **incorrect**. Transaction history is considered immutable and is not meant to be changed.

These facts are clearly stated in the Hedera documentation:

> "State is mutable by definition, constantly changing as transactions are applied to it. In contrast, the history of transactions is generally considered immutable and irreversible."  
[Hedera > Core-concepts > State and History](https://docs.hedera.com/hedera/core-concepts/state-and-history#faq)

**Therefore, the incorrect answers are C and D.**

**A. True**

It is important to avoid targeting only one node for submitting transactions, as relying on a single node introduces a single point of failure. If that node is offline, malicious, or delays your transaction, your transaction may not be processed promptly or at all. Hedera documentation recommends submitting transactions to multiple nodes to mitigate this risk. By doing so, even if one node fails or acts maliciously, another honest node can ensure your transaction is submitted and reaches consensus. This approach enhances reliability and fairness in transaction processing on the network [Hedera Blog: Counter FUD](https://hedera.com/blog/counter-fud), [Hedera Consensus Service Whitepaper](https://hedera.com/hh-consensus-service-whitepaper.pdf).

**B  
False.**

The Hedera testnet allows creation of both ED25519 and ECDSA accounts. This is confirmed by the Hedera Portal, which provides options to create testnet accounts with either key type, and by wallet solutions like HashPack, which also support both ED25519 and ECDSA accounts on testnet. SDK documentation and tutorials further demonstrate account creation with both key types on testnet [Create Testnet Accounts with ED25519 and ECDSA Keys from the Hedera Portal](https://hedera.com/blog/create-accounts-with-ed25519-and-ecdsa-keys-from-the-hedera-portal) [Create and Fund Your Hedera Testnet Account](https://docs.hedera.com/hedera/tutorials/more-tutorials/create-and-fund-your-hedera-testnet-account#option-3-hashpack-wallet).

The officially supported languages in the Hedera SDK are:

- **B. Java**
- **D. Go**
- **F. Javascript**

**Explanation:**  
According to the official Hedera documentation and recent blog posts, the Hedera SDKs that are officially supported (maintained by Hedera) are Java, Go, and JavaScript. Swift, Ruby, and Python are not listed as officially supported languages—Python is community-supported, and there is no mention of official support for Swift or Ruby in the provided knowledge sources [SDKs](https://docs.hedera.com/hedera/sdks-and-apis/sdks) [How to develop on Hedera: Back to the Basics](https://hedera.com/blog/how-to-develop-on-hedera-back-to-the-basics).

So, the correct answers are:  
**B. Java**  
**D. Go**  
**F. Javascript**

**A  
True.**

A client may send the same transaction to multiple nodes via the Hedera SDK. This is a recommended approach to protect against a malicious or slow node that might delay or censor a transaction. By submitting the same transaction to multiple nodes, only the first transaction to reach consensus will be processed, and the duplicates will be ignored. This mechanism ensures fair access and order for the client’s transaction [Fair access v fair ordering and transactions per second examined and explained](https://hedera.com/blog/fair-access-v-fair-ordering-and-transactions-per-second-examined-and-explained) [Hedera Consensus Service Whitepaper](https://hedera.com/hh-consensus-service-whitepaper.pdf).

**D  
False, one can also use previewnet and testnet.**

The knowledge sources clearly state that the Hedera SDK allows you to submit transactions and queries not only to mainnet, but also to testnet and previewnet. The SDK provides pre-configured methods for each network, such as `Client.forMainnet()`, `Client.forTestnet()`, and `Client.forPreviewnet()`, enabling developers to interact with all three environments [Build Your Hedera Client](https://docs.hedera.com/hedera/sdks-and-apis/sdks/client#id-1.-configure-your-hedera-network) [Hedera Release Cycle Overview](https://hedera.com/blog/hedera-release-cycle-overview).


The correct answer is:

**A  
AccountCreateTransaction**

**Explanation of each option:**

- **A. AccountCreateTransaction**  
  This is the correct class used by the Hedera SDK to create new accounts. The knowledge sources provide multiple examples of using `AccountCreateTransaction` to build and execute account creation transactions in JavaScript, Java, and Go. This class allows you to set the account key, initial balance, and other properties before submitting the transaction to the network [Create an account using the account create API](https://docs.hedera.com/hedera/sdks-and-apis/sdks/accounts-and-hbar/create-an-account#create-an-account-using-the-account-create-api) [Step 3: Create Your First Account on Hedera](https://docs.hedera.com/hedera/getting-started-hedera-native-developers/create-an-account#step-3-create-your-first-account-on-hedera).

- **B. AccountNewTransaction**  
  There is no mention of a class named `AccountNewTransaction` in the Hedera SDK documentation or knowledge sources.

- **C. AccountBuildTransaction**  
  There is no mention of a class named `AccountBuildTransaction` in the Hedera SDK documentation or knowledge sources.

- **D. AccountUpdateTransaction**  
  This class is used to update properties of an existing account, not to create a new one [Transactions](https://docs.hedera.com/hedera/sdks-and-apis/sdks/transactions).

Therefore, the only correct answer is **A. AccountCreateTransaction**.

**A  
True**

The knowledge sources confirm that the `.env` file is used to store sensitive information such as private keys as environment variables, which is a security improvement over hardcoding them directly into your code. This approach helps protect your credentials and makes it easier to manage different environments. For example, Hedera documentation and tutorials consistently instruct users to store private keys in a `.env` file and load them into the application, rather than embedding them in the code itself [Build Your Hedera Client](https://docs.hedera.com/hedera/sdks-and-apis/sdks/client#from-a-.env-file) [Deploy a Smart Contract Using Hardhat](https://docs.hedera.com/hedera/tutorials/smart-contracts/deploy-a-smart-contract-using-hardhat-hedera-json-rpc-relay#step-2-configure-project).


The best answer is:

**B  
In order to transfer Hbar you must use TransferHbarTransaction()**

**Explanation:**  
The code uses `TransferTransactions()` (plural), which is not a valid class in the Hedera SDK. The correct class to use for transferring HBAR is `TransferTransaction()` (singular). This is clearly shown in the official documentation and examples, where all HBAR transfers are performed using `TransferTransaction()`:

```javascript
const transaction = new TransferTransaction()
    .addHbarTransfer(senderAccount, Hbar.fromTinybars(-1))
    .addHbarTransfer(recipientAccount, Hbar.fromTinybars(1));
```
[Transfer cryptocurrency](https://docs.hedera.com/hedera/sdks-and-apis/sdks/accounts-and-hbar/transfer-cryptocurrency#methods)

The other options are not correct based on the knowledge sources:
- Negative values for HBAR are valid and indicate a debit.
- The order of `addHbarTransfer` calls is not restricted to receiver first.
- While the net value must be zero, the most immediate error in the code provided is the use of the wrong class name.

The best answer is:

**D  
The net value of the transfer should be zero, ensuring that the total HBAR sent by the sender matches the total received by the recipient.**

**Explanation:**  
According to the Hedera documentation, every HBAR transfer transaction must have a net sum of zero between all sending and receiving accounts. This means the total amount debited (negative values) must exactly match the total amount credited (positive values). In your code, you are sending -75 tinybars and receiving 72 tinybars, which sums to -3, not zero. This will cause the transaction to fail with an error such as `INVALID_ACCOUNT_AMOUNTS` because the transfer list does not net to zero. This requirement is explicitly stated in the documentation: "The net value of HBAR between the sending accounts and receiving accounts must equal zero" [Transfer cryptocurrency](https://docs.hedera.com/hedera/sdks-and-apis/sdks/accounts-and-hbar/transfer-cryptocurrency).

The other options are not correct based on the knowledge sources:
- Negative values are valid for debiting accounts.
- The correct class is `TransferTransaction()`, not `TransferHbarTransaction()`.
- The order of `addHbarTransfer` calls is not restricted; each call specifies an account and an amount.

The provided code block does **not** actually query or output the account balance, so there is no denomination shown in the output. However, according to the knowledge sources, when you do query an account balance using the Hedera SDK or Mirror Node API, the balance is returned in **tinybars** by default. This is explicitly stated: "the network returns information in tinybars (tℏ), a denomination of HBAR. 100,000,000 tℏ are equivalent to 1 ℏ" [Core Concepts: Accounts](https://docs.hedera.com/hedera/core-concepts/accounts).

**Best answer:**

**C  
TINYBAR**

Let's review each option using the knowledge sources provided:

---

### **A**
```js
const newAccountPrivateKey = new PrivateKey("myHardcodedPrivateKey");
const newAccountPublicKey = new PublicKey("myHardcodedPublicKey");
```
**Assessment:**  
This does not generate a new key pair. It simply creates key objects from hardcoded strings, which is not the correct or secure way to generate a key pair. The Hedera SDK provides specific methods for key generation, and there is no indication in the documentation that this approach is valid for generating a new ED25519 key pair.

---

### **B**
```js
const newAccountPrivateKey = PrivateKey.generateED25519();
const newAccountPublicKey = newAccountPrivateKey.publicKey;
```
**Assessment:**  
This is the correct way to generate a new ED25519 private-public key pair in the Hedera SDK. The documentation explicitly shows this pattern for generating and deriving the keys:

```js
const privateKey = await PrivateKey.generateED25519Async();
const publicKey = privateKey.publicKey;
```
or
```js
const privateKey = PrivateKey.generateED25519();
const publicKey = privateKey.publicKey;
```
This matches the code in option B and is the recommended approach in the official documentation [Generate a new key pair](https://docs.hedera.com/hedera/sdks-and-apis/sdks/keys/generate-a-new-key-pair#ed25519).

---

### **C**
```js
const newAccountPrivateKey = PrivateKey.generateRSA();
const newAccountPublicKey = newAccountPrivateKey.getRSAPublicKey();
```
**Assessment:**  
There is no mention in the knowledge sources of a `generateRSA()` method or support for RSA keys for Hedera accounts. Only ED25519 and ECDSA(secp256k1) are supported key types.

---

### **D**
```js
const newAccountPrivateKey = PrivateKey.generateED25519();
```
**Assessment:**  
This generates only the private key. While it is a valid way to generate an ED25519 private key, it does not generate the public key, so it does not fulfill the requirement to generate a private-public key pair.

---

## **Conclusion**

**The correct answer is:**

**B**
```js
const newAccountPrivateKey = PrivateKey.generateED25519();
const newAccountPublicKey = newAccountPrivateKey.publicKey;
```
This is the only option that correctly generates a private-public key pair of type ED25519, as shown in the official Hedera documentation [Generate a new key pair](https://docs.hedera.com/hedera/sdks-and-apis/sdks/keys/generate-a-new-key-pair#ed25519).


**A  
True**

When you create a new account using the Hedera SDK, the client's operator account is the one that funds the newly created account. The operator account pays both the transaction fee and the initial HBAR balance for the new account. This is clearly stated in the documentation:  
> "The account was funded with 20 HBAR from your operator account."  
This means the operator account is responsible for providing the funds for the new account during its creation process [Create an Account - What just happened?](https://docs.hedera.com/hedera/getting-started-hedera-native-developers/create-an-account#what-just-happened).


The correct answer is:

**B  
DER Encoded ED25519 Private Key**

**Explanation:**  
According to the knowledge sources, when setting up your `.env` file for `MY_PRIVATE_KEY`, you should use your ED25519 private key in DER encoding. This is explicitly shown in the setup instructions for Hedera dApps, where the `.env` file example is:

```
MY_ACCOUNT_ID=<enter your ed25519 account id>
MY_PRIVATE_KEY=<enter your ed25519 DER private key>
```
This means you should use the DER-encoded ED25519 private key, not a hex-encoded or ECDSA key, for the `MY_PRIVATE_KEY` field in your `.env` file [Develop a Hedera Dapp with MetaMask, HashPack, and Blade Integration](https://hedera.com/blog/develop-a-hedera-dapp-with-metamask-hashpack-and-blade-integration).

If you are using EVM-compatible tools (like MetaMask or Foundry), you may need a HEX-encoded ECDSA key, but for the `MY_PRIVATE_KEY` field as described in the question, the correct format is DER-encoded ED25519.

**A  
True**

In order to allow another account or contract to transfer HBAR out of your account, you must grant that account or contract an allowance. This is explicitly described in the Hedera documentation, which states that a token owner (including HBAR) must delegate an allowance to a spender before that spender can transfer tokens or HBAR on the owner's behalf. Without this allowance, the transfer cannot occur and will result in an error such as `SPENDER_DOES_NOT_HAVE_ALLOWANCE` if attempted [Approve an allowance](https://docs.hedera.com/hedera/sdks-and-apis/sdks/accounts-and-hbar/approve-an-allowance).


The correct answer is:

**C  
AccountAllowanceApproveTransaction with `.approveHbarAllowance()`**

This is directly supported by the knowledge sources, which state that to grant an allowance for another account to transfer HBAR out of your account, you use the `AccountAllowanceApproveTransaction` class and its `.approveHbarAllowance()` method. Example usage from the documentation:

```js
const transaction = new AccountAllowanceApproveTransaction()
    .approveHbarAllowance(ownerAccount, spenderAccountId, Hbar.from(1));
```
This is the officially documented and supported approach for granting HBAR allowances on Hedera [Approve an allowance - Methods](https://docs.hedera.com/hedera/sdks-and-apis/sdks/accounts-and-hbar/approve-an-allowance#methods).

**A  
True**

When working on your local network, you create and submit transactions and queries to your local consensus node. This is explicitly stated in the documentation: "With your local network set up, you can: Create and submit transactions and queries to a consensus node" [Set Up Your Local Network](https://docs.hedera.com/hedera/sdks-and-apis/sdks/set-up-your-local-network).

**B  
False**

The knowledge sources indicate that when working with a local network, you interact with your own local mirror node to access transaction data generated within your local environment. Interacting with testnet mirror nodes is not a characteristic of working with a local network; testnet mirror nodes provide data from the public Hedera testnet, not from your local transactions. Local transaction data is accessed through your local mirror node, not the testnet mirror nodes [Set Up Your Local Network](https://docs.hedera.com/hedera/sdks-and-apis/sdks/set-up-your-local-network) [How to Set Up Your Own Hedera Local Network Using Docker](https://hedera.com/blog/how-to-set-up-your-own-hedera-local-network-using-docker).

The correct answer is:

**C  
client.forNetwork(node).setMirrorNetwork(mirrorNodeIpAndPort)**

This is confirmed by the official Hedera documentation, which states that to configure your local network client, you should use `Client.forNetwork()` to specify your local consensus node and `.setMirrorNetwork()` to specify your local mirror node. For example:

```js
const node = {"127.0.0.1:50211": new AccountId(3)};
const client = Client.forNetwork(node).setMirrorNetwork("127.0.0.1:5600");
```

This method is specific to local network configuration, while the other options are for public testnet or previewnet environments, not for local development [Set Up Your Local Network](https://docs.hedera.com/hedera/sdks-and-apis/sdks/set-up-your-local-network).

**A  
True**

The knowledge sources confirm that when working with a local Hedera network, the client operator account and private key are provided to you by the local node on startup. This operator account is used to pay for the fees associated with each transaction and query you submit to your local network. The documentation states:

> "You will use the account ID and key provided by the local node on startup to set up your operator account ID and key. The operator is the default account that pays for transaction and query fees."  
[Set Up Your Local Network](https://docs.hedera.com/hedera/sdks-and-apis/sdks/set-up-your-local-network)

Therefore, the statement is **True**.


**A  
True**

The knowledge sources confirm that when working with a local Hedera network, the client operator account and private key are provided to you by the local node on startup. This operator account is used to pay for the fees associated with each transaction and query you submit to your local network. The documentation states:

> "You will use the account ID and key provided by the local node on startup to set up your operator account ID and key. The operator is the default account that pays for transaction and query fees."  
[Set Up Your Local Network](https://docs.hedera.com/hedera/sdks-and-apis/sdks/set-up-your-local-network)

Therefore, the statement is **True**.

The correct class used to create a topic in the Hedera Consensus Service (HCS) is:

**D. TopicCreateTransaction**

- **D. TopicCreateTransaction**  
  This is the correct class. All official Hedera SDKs and documentation use `TopicCreateTransaction` to create a new topic. For example, in JavaScript:
  ```javascript
  const txResponse = await new TopicCreateTransaction().execute(client);
  ```
  And in Java:
  ```java
  TopicCreateTransaction transaction = new TopicCreateTransaction()
      .setTopicMemo("My first HCS topic");
  ```
  This class is consistently shown as the way to create a topic in the Hedera Consensus Service across all supported SDKs [Create a topic](https://docs.hedera.com/hedera/sdks-and-apis/sdks/consensus-service/create-a-topic) [Step 2: Create a new topic](https://docs.hedera.com/hedera/getting-started-hedera-native-developers/create-a-topic#step-2-create-a-new-topic).

**Summary:**  
The only correct answer is **D. TopicCreateTransaction**. The other options are not referenced in the knowledge sources and do not exist in the Hedera SDKs for topic creation.

**A. True**

When submitting a message to a Hedera Consensus Service (HCS) topic, it is necessary to set the `topicID`. This is explicitly required in the SDKs and APIs: the `setTopicId(<topicId>)` method is marked as required when constructing a `TopicMessageSubmitTransaction`. If you do not set the topic ID, the transaction will fail, as shown in both the documentation and reported integration test errors. The topic ID tells the network which topic the message should be submitted to, and omitting it results in an error or exception during transaction processing [Submit a message - Methods](https://docs.hedera.com/hedera/sdks-and-apis/sdks/consensus-service/submit-a-message#methods) [Consensus Service Protobuf Definitions](https://github.com/hashgraph/hedera-services/blob/main/hedera-node/docs/design/services/consensus-service/consensus-service.md) [Github Issue](https://github.com/hiero-ledger/hiero-consensus-node/issues/12567).


The correct answer is:

**C. It controls access to message submission.**

**Explanation:**  
The submit key in the context of Hedera Consensus Service (HCS) topics is used to control who is authorized to submit messages to a topic. If a submit key is set, only transactions signed by that key (or keys, in the case of multi-signature) can submit messages to the topic. This mechanism allows for the creation of private topics, where only authorized parties can write messages. If no submit key is set, the topic is public and anyone can submit messages to it. This is clearly described in the documentation:  
> "When setting a *Submit Key,* your topic becomes a **private topic** because each message needs to be signed by the Submit Key. Therefore, you can control who can submit messages to your topic. A message will be rejected if you don't sign the message or sign with an incorrect key."  
[Submit Message to Private Topic](https://docs.hedera.com/hedera/tutorials/consensus/submit-message-to-private-topic)

The other options are not correct:
- The submit key does **not** determine message order (A), enforce message size limits (B), or execute transactions (D). Its sole purpose is access control for message submission.


The correct answer is:

**D. TopicMessageQuery**

**Explanation:**  
The `TopicMessageQuery` class is used to retrieve (subscribe to) messages from a topic in the Hedera Consensus Service (HCS). This is clearly shown in the official documentation, where `TopicMessageQuery` is used to subscribe to a topic and receive its messages:

```javascript
new TopicMessageQuery()
  .setTopicId(topicId)
  .subscribe(client, null, (message) => {
    // handle received message
  });
```
This class allows you to listen for and process messages as they are published to the topic. The other options are not used for retrieving messages:  
- `TopicCreateTransaction` is for creating topics,  
- `TopicMessageSubmitTransaction` is for submitting messages,  
- `TopicSubscribeTransaction` does not exist in the SDKs.

[Get topic messages](https://docs.hedera.com/hedera/sdks-and-apis/sdks/consensus-service/get-topic-message)

The correct answer is:

**A. The topic's access is restricted to control who can submit messages to it.**

A topic in HCS is referred to as "private" when a submit key is set, which restricts who can submit messages to that topic. However, the data itself remains public on the ledger unless separately encrypted. The term "private" in this context refers only to submission permissions, not to the visibility of the data. As stated in the documentation:

> "When setting a *Submit Key,* your topic becomes a **private topic** because each message needs to be signed by the Submit Key. Therefore, you can control who can submit messages to your topic. Of course, the data is still public, as is all data on a public ledger, but we say the topic is private because the topic is restricted by who can submit messages to it."  
[Submit Message to Private Topic](https://docs.hedera.com/hedera/tutorials/consensus/submit-message-to-private-topic)

Options B, C, and D are incorrect because the data in the topic is still publicly visible unless encrypted by the application, and the "private" designation does not hide or encrypt the data by default.

The correct answer is:

**B. The presence of an adminKey.**

Whether the `updateTopic` and `deleteTopic` functions can be used on a Hedera Consensus Service (HCS) topic is determined by the presence of an adminKey. If an adminKey is set when the topic is created, the adminKey must sign any update or delete transaction, and both operations are permitted. If no adminKey is set, the topic is immutable except that anyone can extend its expiration time, and deletion is not allowed. This is clearly stated in the documentation:  
> "If no adminKey is specified, updateTopic may only be used to extend the topic's expirationTime, and deleteTopic is disallowed."  
[ConsensusCreateTopicTransactionBody](https://docs.hedera.com/hedera/sdks-and-apis/hedera-api/consensus/consensuscreatetopic#consensuscreatetopictransactionbody)

Other factors such as the number of messages, visibility status, or data encryption do not determine whether these functions can be used.

The required methods when creating a token using the Hedera Token Service are:

- **B. setTokenName(name)**
- **D. setTokenSymbol(symbol)**
- **E. setTreasuryAccountID(treasuryAccountId)**

These three methods are explicitly required to create a token: you must set the token's name, symbol, and treasury account ID. The other options, **A. setTokenType(TokenType)** and **C. setAdminKey(key)**, are optional—if not specified, defaults are used (e.g., the token will be fungible and immutable if no admin key is set) [see here](https://docs.hedera.com/hedera/tutorials/token/create-and-transfer-your-first-fungible-token#id-1.-create-a-fungible-token) [see here](https://docs.hedera.com/hedera/sdks-and-apis/sdks/token-service/define-a-token#methods).

**Correct answers:**  
B, D, E

The correct class used to create a token on Hedera is:

**A. TokenCreateTransaction**

This is clearly shown in the official documentation and tutorials, where `TokenCreateTransaction` is used to define and create new tokens on the Hedera network. The other options are either not mentioned or are used for different purposes, such as minting tokens rather than creating them [Create and Transfer Your First Fungible Token](https://docs.hedera.com/hedera/tutorials/token/create-and-transfer-your-first-fungible-token#id-1.-create-a-fungible-token) [Create a Token](https://docs.hedera.com/hedera/getting-started-hedera-native-developers/create-a-token#step-3-create-your-first-token-on-hedera).

**A. True**

If you do not specify the token type when creating a token, it will default to creating a fungible token. This is explicitly stated in the documentation:  
> "The SDKs default to creating fungible tokens if the token type during creation is not specified."  
[Token types](https://docs.hedera.com/hedera/sdks-and-apis/sdks/token-service/token-types)

The main characteristic of a royalty fee in relation to NFTs is:

**C. It is charged each time NFT ownership is transferred and sent to the royalty collector.**

This is supported by the documentation, which states that a royalty fee is assessed and applied each time the ownership of an NFT is transferred, and the fee is sent to the designated royalty collector account. If no fungible value is exchanged, a fallback fee may be charged instead [Royalty Fee (NFTs)](https://docs.hedera.com/hedera/core-concepts/tokens/hedera-token-service-hts-native-tokenization/custom-fee-schedule#id-3-royalty-fee-nfts) [Custom token fees](https://docs.hedera.com/hedera/sdks-and-apis/sdks/token-service/custom-token-fees#royalty-fee).

**A. True**

The supply key must be set in order to mint tokens and increase the supply. If no supply key is defined, minting operations will fail with the error `TOKEN_HAS_NO_SUPPLY_KEY` ([source](https://docs.hedera.com/hedera/sdks-and-apis/sdks/token-service/mint-a-token))

The purpose of specifying the initial supply when creating fungible tokens is:

**B. To determine the amount of tokens initially put into circulation.**

When you create a fungible token, the `initialSupply` sets the number of the smallest units of the token that will be in circulation immediately after creation. This amount is sent to the Treasury Account, but its primary purpose is to define how many tokens are available from the start ([TokenCreate](https://docs.hedera.com/hedera/sdks-and-apis/hedera-api/token-service/tokencreate), [Token Properties](https://docs.hedera.com/hedera/core-concepts/tokens/hedera-token-service-hts-native-tokenization/token-properties)).**B. To determine the amount of tokens initially put into circulation.**

When creating fungible tokens, the initial supply specifies the amount of tokens that will be put into circulation at the time of creation. This initial supply is sent to the Treasury Account and is expressed in the smallest denomination possible for the token [TokenCreate](https://docs.hedera.com/hedera/sdks-and-apis/hedera-api/token-service/tokencreate) [Token Properties](https://docs.hedera.com/hedera/core-concepts/tokens/hedera-token-service-hts-native-tokenization/token-properties).

The purpose of setting the treasury account ID when creating a token is:

**D. To receive the initial supply or newly minted NFTs**

According to the knowledge sources, the treasury account is the account that receives the initial supply of tokens upon creation and any additional tokens that are minted later. It is a required field during token creation and is central to managing the token's supply and distribution ([TokenCreate](https://docs.hedera.com/hedera/sdks-and-apis/hedera-api/token-service/tokencreate), [Token Properties](https://docs.hedera.com/hedera/core-concepts/tokens/hedera-token-service-hts-native-tokenization/token-properties)).

The purpose of an Associate transaction is:

**B  
Allows a user to receive a new fungible or new nonfungible token**

This is because, on Hedera, an account must first be associated with a token before it can receive or send that token. The associate transaction is the required step that enables this capability for both fungible and non-fungible tokens. Without this association, token transfers to the account will fail [see here](https://docs.hedera.com/hedera/sdks-and-apis/sdks/token-service/associate-tokens-to-an-account) and [here](https://docs.hedera.com/hedera/tutorials/token/create-and-transfer-your-first-nft#id-3.-associate-user-accounts-with-the-nft).

The best answer is:

**C  
TOKEN_NOT_ASSOCIATED_TO_ACCOUNT**

This error message can occur when transferring a token to another user if the recipient account has not yet associated with the token. The Hedera documentation explicitly lists `TOKEN_NOT_ASSOCIATED_TO_ACCOUNT` as a possible error in this scenario [see here](https://docs.hedera.com/hedera/sdks-and-apis/sdks/token-service/errors).

The correct answer is:

**D  
TokenType.NonFungibleUnique**

This is the required token type for creating an NFT on Hedera. The documentation and code examples clearly specify that `TokenType.NonFungibleUnique` must be used when creating non-fungible tokens (NFTs) [see here](https://docs.hedera.com/hedera/sdks-and-apis/sdks/token-service/token-types).

The correct answer is:

**C  
Set the initial supply to 0.**

When creating a non-fungible token (NFT) on Hedera, you must set the initial supply to 0. This is because NFTs are minted individually after the token class is created, and the initial supply parameter is not used to pre-mint NFTs. This requirement is clearly stated in the documentation: "For non-fungible tokens, ... the initial supply for an NFT is required to be set to 0" and "When creating an NFT, the decimals and initial supply must be set to zero" [see here](https://docs.hedera.com/hedera/tutorials/token/create-and-transfer-your-first-nft#id-1.-create-a-non-fungible-token-nft) and [here](https://hedera.com/blog/developer-quick-start-nfts-and-metadata).


The correct answer is:

**C  
It controls how divisible the token is and how fractions of the token's value are handled**

The `.setDecimals()` method defines the number of decimal places a fungible token can be divided into, determining its divisibility and how fractional values are represented and transferred. For example, if `decimals` is set to 2, the smallest unit is 0.01 of the token. This property cannot be changed after creation [see here](https://docs.hedera.com/hedera/core-concepts/tokens/hedera-token-service-hts-native-tokenization/token-properties) and [here](https://docs.hedera.com/hedera/sdks-and-apis/hedera-api/token-service/tokencreate#tokencreatetransactionbody).

**A  
True**

The knowledge sources state that the supply key is required to mint or burn tokens, and it is important to keep your private keys secure so you can control your token in the future. Saving the supply key to a file ensures you can later use it to change the supply of your tokens, as recommended in the documentation: "Keep your private keys secure - anyone with access can control your token" and "The Supply Key must sign the transaction" [see here](https://docs.hedera.com/hedera/getting-started-hedera-native-developers/create-a-token#step-2-generate-token-keys).


**A  
True**

When creating an NFT on Hedera, `.setDecimals()` must be set to 0. This is a required property for non-fungible tokens, as confirmed in the official documentation: "When creating an NFT, the decimals and initial supply must be set to zero" and "For tokens of type NON_FUNGIBLE_UNIQUE - value must be 0" [see here](https://docs.hedera.com/hedera/tutorials/token/create-and-transfer-your-first-nft#id-1.-create-a-non-fungible-token-nft) and [here](https://docs.hedera.com/hedera/sdks-and-apis/hedera-api/token-service/tokencreate#tokencreatetransactionbody).


The best answer is:

**B  
To "Know your Customer" and gather further details about them.**

However, to clarify based on the knowledge sources:  
Setting a KYC key on a Hedera token is specifically to enforce KYC (Know Your Customer) compliance, meaning only accounts that have been granted KYC status (i.e., have been verified or authorized) can transact with the token. This is used to ensure regulatory compliance and restrict token usage to approved parties. The KYC key itself does not gather customer details, but it is used to enforce that only KYC-approved accounts can interact with the token. This aligns most closely with option B, even though the actual function is enforcement rather than data collection [Hedera Token Service (HTS) Native Tokenization](https://docs.hedera.com/hedera/core-concepts/tokens/hedera-token-service-hts-native-tokenization#token-management) [HH Tokenization Whitepaper](https://hedera.com/hh_tokenization-whitepaper_v2_20210101.pdf).


**A  
True**

After generating a token ID for an NFT collection on Hedera, it is necessary to mint NFTs as a separate step. The token creation process only establishes the NFT class and its properties; individual NFTs (with unique serial numbers and metadata) are created through the minting process that follows. This is explicitly stated in the knowledge sources: "Once the token is created, you must mint each NFT using the token mint operation" and "For non-fungible tokens, the token ID represents an NFT class. Once the token is created, you must mint each NFT..." [Create and Transfer Your First NFT](https://docs.hedera.com/hedera/tutorials/token/create-and-transfer-your-first-nft#id-2.-mint-a-new-nft) [Hedera Token Service - How to Mint NFTs](https://docs.hedera.com/hedera/tutorials/token/hedera-token-service-part-1-how-to-mint-nfts#create-a-non-fungible-token-nft).


The best answer is:

**C  
It is the data that is being tokenized onto the NFT.**

Metadata in NFTs refers to the structured data that is attached to the NFT at the time of minting. This metadata defines the NFT's unique characteristics—such as its name, description, image, attributes, and other properties—and is what is actually being tokenized and referenced by wallets, dApps, and marketplaces. The metadata is essential for the usability, discoverability, and value of the NFT, as it provides all the contextual information about what the NFT represents ([Hedera Token Metadata Standard](https://docs.hedera.com/hedera/core-concepts/tokens/hedera-token-service-hts-native-tokenization/token-properties#token-metadata-standard), [How to Make Sure Your Hedera NFT Metadata Is Correct](https://hedera.com/blog/hedera-nft-metadata-hip412)).


The best answer is:

**C  
InterPlanetary File System (IPFS)**

According to the knowledge sources, both the data (such as images or other media) and the metadata for NFTs on Hedera are usually stored on decentralized storage solutions like IPFS. The NFT on the Hedera ledger contains a pointer (CID or URI) to the metadata file on IPFS, which can also reference the actual media file. This method is widely used and recommended for ensuring immutability and long-term accessibility of NFT assets ([NFT storage: Why it matters](https://hedera.com/blog/nft-storage-why-it-matters), [Create and Transfer Your First NFT](https://docs.hedera.com/hedera/tutorials/token/create-and-transfer-your-first-nft#id-2.-mint-a-new-nft)).

The defining characteristic of decentralized applications (dApps) is:

**C  
dApps operate on a blockchain or P2P network.**

This is supported by the knowledge sources, which state that dApps are applications that run on a peer-to-peer (P2P) network or blockchain, rather than a centralized server. This decentralized architecture is what distinguishes dApps from traditional, centralized applications [What is a decentralized application (dapp)?](https://hedera.com/learning/distributed-ledger-technologies/what-is-a-decentralized-application-dapp), [Hedera Glossary](https://docs.hedera.com/hedera/support-and-community/glossary#d).

The benefits of having a distributed application, according to the knowledge sources, are:

**A. No required trusted party to operate the network**  
Distributed applications do not require a trusted central party. Instead, they operate on decentralized networks where trust is established through consensus, making them "trustless" systems [What is a decentralized application (dapp)?](https://hedera.com/learning/distributed-ledger-technologies/what-is-a-decentralized-application-dapp) [Glossary: Trustless](https://docs.hedera.com/hedera/support-and-community/glossary#trustless).

**B. Improves trust through transparency**  
Distributed applications improve trust by making all transactions and changes transparent and auditable to all participants on the network [What is a decentralized application (dapp)?](https://hedera.com/learning/distributed-ledger-technologies/what-is-a-decentralized-application-dapp).

**C. Lowers risk of security breaches due to the absence of a central database.**  
Because there is no single central database, distributed applications reduce the risk of a single point of failure and make it more difficult for attackers to compromise the system [What is a decentralized application (dapp)?](https://hedera.com/learning/distributed-ledger-technologies/what-is-a-decentralized-application-dapp).

**D. Allows for easier integration of third-party plugins and extensions into dApps.**  
The knowledge sources do not explicitly mention this as a general benefit of distributed applications.

**Therefore, the correct answers are:**

- A
- B
- C

✅ **Correct Answer: C**

```javascript
const initData = await hashconnect.init(appMetadata);
```

### Explanation:

In the **Hedera HashConnect SDK**, the initialization of HashConnect with your app’s metadata (like name, description, icon, etc.) is done using the `init()` method.

Example:

```javascript
import { HashConnect } from "hashconnect";

const hashconnect = new HashConnect();

const appMetadata = {
  name: "MyHederaApp",
  description: "A sample dApp using HashConnect",
  icon: "https://example.com/icon.png"
};

const initData = await hashconnect.init(appMetadata);
```

* `init()` sets up the connection.
* `await` is required since it returns a promise.
* The returned `initData` contains:

  * `topic`
  * `privKey`
  * `pairingString`
  * `encryptionKey`

So the correct line is:
👉 **`const initData = await hashconnect.init(appMetadata);`**

✅ **Correct Answer: C**

```text
To invoke the wallet and ask the user to sign the transaction.
```

### Explanation:

In **HashConnect**, the `executeWithSigner` method is used to **send a transaction that requires user approval** through their connected wallet.

It:

* Invokes the connected **wallet’s signing flow**
* Prompts the **user to review and sign** the transaction
* Then **submits** it to the Hedera network

So, it’s not just execution — it **executes with the wallet’s signer**, ensuring the user’s private key never leaves their wallet.

**Example:**

```javascript
const response = await hashconnect.executeWithSigner(signer, transaction);
```

Here:

* `signer` = wallet signer provided after pairing
* `transaction` = a pre-built Hedera transaction (e.g., `TransferTransaction`)

👉 Therefore, the correct answer is:
**C. To invoke the wallet and ask the user to sign the transaction.**
✅ **Correct Answer: B**

```text
The front end of an application can talk to a shared database.
```

### Explanation:

One of the **core features** of a **Decentralized Application (dApp)** is that its frontend (often built like a regular web app) communicates directly with a **shared, decentralized database** — typically a **blockchain or distributed ledger** — rather than a centralized server.

This “shared database” ensures:

* **Transparency** (all participants see the same state)
* **Immutability** (data can’t be tampered with)
* **Decentralized control** (no single authority owns the data)

So while the frontend may look familiar, the backend is **decentralized** and powered by smart contracts or distributed storage — not a private, centralized server.

👉 Therefore, the correct answer is:
**B. The front end of an application can talk to a shared database.**
✅ **Correct Answer: A**

```text
To establish connections between Hedera apps and wallets.
```

### Explanation:

The **HashConnect** library is specifically designed to **connect Hedera-based decentralized applications (dApps)** with **wallets** (such as HashPack).

It enables:

* **Secure communication** between a dApp and a wallet
* **Transaction signing** through the user’s wallet
* **Account pairing** and **session management**

In short, it acts as the **bridge** that lets your dApp request users to **connect, sign, and interact** with the Hedera network using their existing wallet.

👉 Therefore, the correct answer is:
**A. To establish connections between Hedera apps and wallets.**


How can you correctly retrieve the topic ID after executing a topic create transaction?
Choose only ONE best answer.

A
const createTopicTransactionResponse = await new TopicCreateTransaction().execute(client);
const newTopicId = createTopicTransactionResponse.topicId

B
const createTopicTransactionResponse = await new TopicCreateTransaction().execute(client);
const createTopicReceipt = await createTopicTransactionResponse.getReceipt(client);
const newTopicId = createTopicReceipt.getTopicId();

C
const createTopicTransactionResponse = await new TopicCreateTransaction().execute(client);
const createTopicReceipt = await createTopicTransactionResponse.getReceipt(client);
const newTopicId = createTopicTransactionResponse.topicId;

D
const createTopicTransactionResponse = await new TopicCreateTransaction().execute(client);
const newTopicId = createTopicTransactionResponse.getTopicId();
The correct way to retrieve the topic ID after executing a topic create transaction, according to the knowledge sources, is:

B

const createTopicTransactionResponse = await new TopicCreateTransaction().execute(client);
const createTopicReceipt = await createTopicTransactionResponse.getReceipt(client);
const newTopicId = createTopicReceipt.getTopicId();
This approach matches the documented examples, where you execute the transaction, get the receipt, and then retrieve the topic ID from the receipt. The other options do not align with the official Hedera SDK usage shown in the sources (Create a Topic).

Answer based on the following sources:

Step 2: Create a new topic
docs.hedera.com/hedera
Create a Topic

Why not c?
Option C is not correct because, according to the knowledge sources, the topicId is not available directly on the transaction response object (createTopicTransactionResponse). Instead, you must first call .getReceipt(client) on the transaction response to obtain a receipt object, and then retrieve the topicId from that receipt. The correct sequence is:

const createTopicTransactionResponse = await new TopicCreateTransaction().execute(client);
const createTopicReceipt = await createTopicTransactionResponse.getReceipt(client);
const newTopicId = createTopicReceipt.topicId;
This pattern is shown in multiple official Hedera examples, where the topic ID is always accessed from the receipt, not directly from the transaction response (see here, see also). Option C incorrectly tries to access topicId from the transaction response, which is not supported by the SDK as documented.

Answer based on the following sources:

1. Create your first topic
docs.hedera.com/hedera
Submit Your First Message

Step 2: Create a new topic
docs.hedera.com/hedera
Create a Topic

Is this explanation correct "Option C:
const createTopicTransactionResponse = await new TopicCreateTransaction().execute(client);
const createTopicReceipt = await createTopicTransactionResponse.getReceipt(client);
const newTopicId = createTopicTransactionResponse.topicId;


Here’s why this is incorrect 👇

🧠 Key Concept:

When you call:

const createTopicTransactionResponse = await new TopicCreateTransaction().execute(client);


This returns a TransactionResponse, not a receipt, and it doesn’t contain the topicId.
It only includes:

transactionId

nodeId

some metadata about the execution

The topic ID is only created after the transaction is processed and confirmed on the network — and that info is stored in the receipt, not the initial response.

✅ Correct flow (Option B)
const createTopicTransactionResponse = await new TopicCreateTransaction().execute(client);
const createTopicReceipt = await createTopicTransactionResponse.getReceipt(client);
const newTopicId = createTopicReceipt.topicId;


getReceipt(client) waits for the network to finalize the transaction.

Once confirmed, the receipt contains the topicId (or contract ID, token ID, etc., depending on the transaction type).

🚫 Why Option C fails

In Option C:

const newTopicId = createTopicTransactionResponse.topicId;


That property doesn’t exist on the TransactionResponse object — meaning you’d get undefined or a runtime error.

✅ In summary:
Only after fetching the receipt can you access topicId.
That’s why Option B is correct — and C is not."
Yes, your explanation is correct and aligns with the information in the official Hedera documentation.

When you execute await new TopicCreateTransaction().execute(client);, you receive a TransactionResponse object. This object does not contain the topicId. It only includes metadata such as transactionId and nodeId TransactionResponse.
The topicId is only available after the transaction has reached consensus on the network, which is when you call .getReceipt(client) on the transaction response. The receipt contains the topicId and other relevant information TransactionReceipt.
Therefore, in Option C, createTopicTransactionResponse.topicId will be undefined or not exist, because topicId is not a property of TransactionResponse Get a transaction receipt.
The correct flow is to get the receipt and then access the topicId from the receipt, as shown in Option B. Your summary and reasoning are accurate and supported by the knowledge sources.

The correct answer is:

**B**
```javascript
const topicMessageTx = await new TopicMessageSubmitTransaction()
    .setTopicId(newTopicId)
    .setMessage("hello, HCS!")
    .freezeWithSigner(signer);

const topicMessageSubmit = await topicMessageTx.executeWithSigner(signer);
```

**Reasoning:**  
According to the knowledge sources, the correct methods to use are `.setTopicId()` for the topic and `.setMessage()` for the message. When using a wallet or external signer (such as HashConnect), you should freeze the transaction with the signer and then execute it with the signer. This pattern is shown in the official documentation for signing and submitting transactions with a local wallet or external signer, where `.freezeWithSigner(signer)` and `.executeWithSigner(signer)` are used. The other options use incorrect method names or do not follow the correct signing flow ([LocalProvider example](https://docs.hedera.com/hedera/sdks-and-apis/sdks/signature-provider/local-provider#sign-with-local-wallet-example)).

If you need to submit a message to a Hedera Consensus Service topic using HashConnect or a similar wallet integration, **Option B** is the correct approach.

**A  
True**

Based on the knowledge sources, when a user selects "Send Topic Message" in a dApp, the transaction is sent to the user's wallet (via HashConnect or WalletConnect) for approval. The user must then sign (approve) the transaction in their wallet, after which the message is submitted to the Hedera network. This process ensures that the user maintains control and security over their private keys, and only approved transactions are submitted to the network [HashConnect Secure Signing for dApps](https://hedera.com/blog/hashconnect-secure-signing-for-dapps-built-on-hedera) [Wallets on Hedera Collaborate to Launch WalletConnect Integrations](https://hedera.com/blog/wallets-on-hedera-collaborate-to-launch-walletconnect-integrations).

A  
True

The Hedera Smart Contract Service uses the Solidity smart contract language. This is confirmed by multiple sources stating that Hedera is EVM-compatible and supports Solidity for writing and deploying smart contracts on its network [What is Hedera?](https://hedera.com/learning/hedera-hashgraph/what-is-hedera-hashgraph), [Hedera Hashgraph Announces Mainnet Launch of EVM-Compatible Smart Contracts 2.0](https://hedera.com/blog/hedera-hashgraph-announces-mainnet-launch-of-evm-compatible-smart-contracts-2-0?), [Creating Smart Contracts](https://docs.hedera.com/hedera/core-concepts/smart-contracts/creating-smart-contracts).

The best answer is:

**D  
Solidity is an object-oriented, high-level language used for implementing smart contracts.**

This is directly supported by the knowledge sources, which state that Solidity is a Turing-complete, object-oriented programming language for developing smart contracts on the Ethereum Virtual Machine (EVM) and other compatible distributed networks [[Hedera Glossary: Solidity](https://docs.hedera.com/hedera/support-and-community/glossary#solidity)].

The best answer is:

**B  
ABI bridges smart contracts and web apps, facilitating communication between high-level languages like JavaScript and the EVM bytecode.**

The knowledge sources explain that the Application Binary Interface (ABI) is the standard way to interact with contracts in the Ethereum ecosystem, both from outside the blockchain (such as web applications) and for contract-to-contract interaction. The ABI defines how data should be encoded and decoded, enabling communication between high-level languages and the EVM bytecode [[Hedera Glossary: ABI](https://docs.hedera.com/hedera/support-and-community/glossary#a)], [[Compiling Smart Contracts: ABI](https://docs.hedera.com/hedera/core-concepts/smart-contracts/compiling-smart-contracts#smart-contract-application-binary-interface-abi)].

B  
**False**

The knowledge sources do not mention obtaining smart contract bytecode using `const bytecode = helloHedera.data.bytecode.object;`. Instead, they show that bytecode is typically obtained by reading the compiled contract file, for example using `fs.readFileSync("...")` or similar methods [[How to Deploy Smart Contracts on Hedera](https://hedera.com/blog/how-to-deploy-smart-contracts-on-hedera-part-1-a-simple-getter-and-setter-contract)], [[How to Set Up Foundry to Test Smart Contracts on Hedera](https://hedera.com/blog/how-to-set-up-foundry-to-test-smart-contracts-on-hedera)]. There is no evidence in the provided sources that the method in the question is correct.

The correct code snippet that calls a function of a smart contract (read-only, does not change state) is:

**B**
```javascript
const contractQuery = await new ContractCallQuery()
    .setGas(10000)
    .setContractId(newConractId)
    .setFunction("get_message")
    .setQueryPayment(new Hbar(2));

const response = await contractQuery.execute(client);
const message = response.getString(0);
```

This matches the documented approach for querying a smart contract function on Hedera using `ContractCallQuery`, specifying the gas, contract ID, function name, and query payment, and then retrieving the result with `.getString(0)` for a string return value [see example](https://docs.hedera.com/hedera/sdks-and-apis/sdks/smart-contracts/get-a-smart-contract-function#methods).


The correct class used to execute a smart contract function (that will change state) on Hedera is:

**C  
ContractExecuteTransaction()**

This is confirmed in the Hedera documentation, which states that `ContractExecuteTransaction()` is used to call a function of a smart contract instance that may change state, such as updating variables or transferring tokens. In contrast, `ContractCallQuery()` is used for read-only queries that do not change state [see documentation](https://docs.hedera.com/hedera/sdks-and-apis/sdks/smart-contracts/call-a-smart-contract-function).

**A  
True**

You can use the `ContractCreateFlow()` class to perform a `FileCreateTransaction()`, `FileAppendTransaction()`, and `ContractCreateTransaction()` in a single call, resulting in deploying a smart contract on Hedera. This is explicitly stated in the knowledge sources:

> "Store your contract on Hedera using `ContractCreateFlow()`. This single call performs `FileCreateTransaction()`, `FileAppendTransaction()`, and `ContractCreateTransaction()` for you."  
[See source](https://docs.hedera.com/hedera/tutorials/token/create-and-transfer-an-nft-using-a-solidity-contract#id-1.-create-an-nft-creator-smart-contract)

> "The function contracts.deployContractFcn uses ContractCreateFlow() to store the bytecode and deploy the contract on Hedera. This single call handles for you the operations FileCreateTransaction(), FileAppendTransaction(), and ContractCreateTransaction()."  
[See source](https://hedera.com/blog/how-to-generate-a-random-number-on-hedera)

This confirms the statement is correct.

**A  
True**

You can use the `ContractCreateFlow()` class to perform a `FileCreateTransaction()`, `FileAppendTransaction()`, and `ContractCreateTransaction()` in a single call, resulting in deploying a smart contract on Hedera. This is explicitly stated in the knowledge sources:

> "Store your contract on Hedera using `ContractCreateFlow()`. This single call performs `FileCreateTransaction()`, `FileAppendTransaction()`, and `ContractCreateTransaction()` for you."  
[See source](https://docs.hedera.com/hedera/tutorials/token/create-and-transfer-an-nft-using-a-solidity-contract#id-1.-create-an-nft-creator-smart-contract)

> "The function contracts.deployContractFcn uses ContractCreateFlow() to store the bytecode and deploy the contract on Hedera. This single call handles for you the operations FileCreateTransaction(), FileAppendTransaction(), and ContractCreateTransaction()."  
[See source](https://hedera.com/blog/how-to-generate-a-random-number-on-hedera)

This confirms the statement is correct.

The correct class to use when creating a new NFT token via a smart contract on Hedera is:

**D  
ContractExecuteTransaction()**

This class is used to execute a function on a smart contract that changes state, such as creating a new NFT token. The knowledge sources provide clear examples where `ContractExecuteTransaction()` is used to call the contract function responsible for NFT creation, confirming it is the appropriate choice for this operation [see example](https://docs.hedera.com/hedera/tutorials/token/create-and-transfer-an-nft-using-a-solidity-contract#id-3.-execute-the-contract-to-create-an-nft).

The correct answer is:

**C  
contractFunctionResult.getAddress(0)**

This is supported by the knowledge sources, which show that after calling `.getRecord()` on the executed `createTokenTx`, you access the result returned by the smart contract function using `contractFunctionResult.getAddress(0)`. This retrieves the address (such as the new token's Solidity address) returned by the `createNFT` function [see example](https://docs.hedera.com/hedera/tutorials/token/create-and-transfer-an-nft-using-a-solidity-contract#id-3.-execute-the-contract-to-create-an-nft).

The correct statements about Hashio and its purpose, based on the provided knowledge sources, are:

**C. Hashio is a hosted instance of the JSON-RPC Relay project & is hosted by Swirlds Labs.**  
This is true. Hashio is a public RPC endpoint hosted by Swirlds Labs and is an instance of the open-source Hedera JSON-RPC Relay project. It provides a familiar Ethereum-like API for interacting with the Hedera network [Hashio documentation](https://docs.hedera.com/hedera/tutorials/more-tutorials/json-rpc-connections/hashio).

**D. Hashio enables smart contract developers to use wallets such as Metamask and tools and libraries such as ethers.js, web3.js, hardhat, truffle,**  
This is also true. Hashio allows developers to use standard EVM-compatible tools and wallets (like MetaMask, ethers.js, web3.js, Hardhat, and Truffle) to deploy and interact with smart contracts on Hedera [Leveraging Ethereum Developer Tools on Hedera](https://hedera.com/blog/leveraging-ethereum-developer-tools-on-hedera).

**A** is incorrect because Hashio itself is not the open-source project; it is a hosted service based on the open-source JSON-RPC Relay.  
**B** is incorrect because Hashio is not exclusively focused on retail users; it is primarily intended for developers for development and testing purposes.

**Correct answers:**  
- **C**
- **D**

The best answer is:

**C. It allows smart contract developers to use tools like ethers.js and MetaMask.**

Hashio is a hosted instance of the JSON-RPC Relay that enables developers to use familiar Ethereum tools and wallets—such as ethers.js, web3.js, Hardhat, Truffle, and MetaMask—on the Hedera network. This compatibility makes it much easier for developers to transition from Ethereum to Hedera without having to learn new tools or workflows [Leveraging Ethereum Developer Tools on Hedera](https://hedera.com/blog/leveraging-ethereum-developer-tools-on-hedera) [JSON-RPC Providers Now on Hedera](https://hedera.com/blog/json-rpc-providers-now-on-hedera-accelerating-developer-adoption-with-evm-tooling-and-wallets).


The correct answer is:

**C. It wraps signed Ethereum transactions into Hedera API (HAPI) transactions and executes them, facilitating cross-network communication.**

The knowledge sources explain that the JSON-RPC Relay enables Ethereum-compatible wallets to interact with the Hedera network by wrapping Ethereum transaction bytes in a Hedera API (HAPI) call. This allows transactions created and signed in wallets like MetaMask to be executed on Hedera, making the transition seamless for developers and users familiar with Ethereum tools [How does the JSON-RPC Relay work?](https://hedera.com/blog/anything-you-can-do-you-can-do-on-hedera-introducing-the-json-rpc-relay).

The correct answer is:

**D. Hex Encoded ECDSA Private Key**

To import your Hedera account into MetaMask, you need to use the hex encoded ECDSA private key. MetaMask only supports ECDSA (secp256k1) keys in hex format, not DER-encoded or ED25519 keys. This is clearly stated in the documentation and tutorials for integrating Hedera accounts with MetaMask, which instruct users to use the hex encoded ECDSA private key for account import [Deploy Smart Contracts on Hedera Using Truffle](https://docs.hedera.com/hedera/tutorials/smart-contracts/deploy-smart-contracts-on-hedera-using-truffle#create-an-account-that-has-ecdsa-keys) [Hedera Testnet Faucet](https://docs.hedera.com/hedera/getting-started-evm-developers/hedera-testnet-faucet) [Leveraging Ethereum Developer Tools on Hedera](https://hedera.com/blog/leveraging-ethereum-developer-tools-on-hedera).

The correct Hedera Testnet Chain ID is:

**C. 296**

This is confirmed in the official documentation, which states that the Hedera Testnet uses chain ID 296 for network configuration in tools like MetaMask and JSON-RPC relays [Add Hedera to MetaMask](https://docs.hedera.com/hedera/getting-started-evm-developers/add-hedera-to-metamask) [JSON-RPC Relay Endpoints](https://docs.hedera.com/hedera/core-concepts/smart-contracts/json-rpc-relay#community-hosted-json-rpc-relays).

✅ **Correct Answer: B**

```text
False
```

---

### 🧠 **Explanation:**

You **do not** need to manually add the Hedera Testnet to **MetaMask** to connect to it.

* **Hedera** is **not an EVM chain by default** — it’s its own distributed ledger network.
* When working with **HashPack** or **HashConnect**, your dApp connects directly to the **Hedera Testnet** using the SDK or the wallet connection, **not through MetaMask**.

Even though Hedera now supports **EVM-compatible smart contracts (via Hedera Smart Contract Service)**, you still use Hedera-specific tools (like the SDK, HashConnect, or HashPack) — not MetaMask’s manual network addition.

---

✅ **Therefore, the correct answer is:**
**B. False**
**B. False**

You do not need to manually add the Hedera Testnet network to MetaMask; there are multiple ways to add it. The official documentation describes several options, including connecting via HashScan (which prompts you to add the network if it isn't already present), using ChainList for a one-click addition, or adding it manually if you prefer. Manual addition is just one of several available methods, not a requirement [How to Connect MetaMask to Hedera](https://docs.hedera.com/hedera/tutorials/smart-contracts/how-to-connect-metamask-to-hedera).

The correct answer is:

**C. Ethers.js**

This is supported by the knowledge sources, which show that Ethers.js is used to create and interact with EVM transactions on MetaMask when working with Hedera. Tutorials and example dApps specifically use Ethers.js for connecting to MetaMask, deploying contracts, and interacting with smart contracts on Hedera [How to Create a Smart Contract App on Hedera Using Solidity, React JS, MetaMask, and Ethers JS – A Simple Counter](https://hedera.com/blog/how-to-create-a-smart-contract-app-on-hedera-using-solidity-react-js-metamask-and-ethers-js-a-simple-counter) [MetaMask Hedera Wallet Snap Tutorial](https://docs.hedera.com/hedera/open-source-solutions/hedera-wallet-snap-by-metamask/metamask-hedera-wallet-snap-tutorial#step-1-pair-metamask-wallet-select-network-and-account).
When you “associate” an HTS token (Hedera Token Service token), that’s a Hedera-specific process — not something handled by MetaMask or via ethers.Contract().

Association in Hedera is a native operation on the Hedera network.

It must be done through:

The Hedera SDK (TokenAssociateTransaction), or

A smart contract call that triggers an HTS precompile (not just a generic ERC-20 interaction).

Example with the SDK:

new TokenAssociateTransaction()
  .setAccountId(accountId)
  .setTokenIds([tokenId])
  .execute(client);


Using ethers.Contract() only works once the token is already associated and you’re interacting via the EVM side, e.g., for transfers — not for the initial association.
Based on the knowledge sources, the correct answer is **A. True**.

The official Hedera tutorials demonstrate that, to prepare for associating an HTS token with MetaMask, you create a contract instance using the HTS token address and `ethers.Contract()`. This allows you to call the `associate()` function from your dApp, which is the standard approach for token association via MetaMask and EVM tooling. For example:

```js
const token = new ethers.Contract(tokenAddress, ["function associate()"], signer);
await token.associate({ gasLimit: 800_000 });
```

This process is explicitly shown in the Hedera documentation for minting NFTs and associating tokens using EVM-compatible tools and MetaMask [HTS x EVM - How to Mint NFTs (Part 1)](https://docs.hedera.com/hedera/tutorials/smart-contracts/hts-x-evm-part-1-how-to-mint-nfts#step-4-minting-an-hts-nft).

So, the statement is **True**.

The correct answer is:

**C. const myContract = new ethers.Contract(tokenAddress, abi, signer); const associateTx = await myContract.associate({gasLimit: 100000});**

This is the correct approach for associating an HTS token with a MetaMask account using EVM-compatible tooling. The knowledge sources demonstrate that you create a contract instance using `ethers.Contract()` with the token address, ABI (which includes the `associate()` function), and signer, then call the `associate()` method on that contract instance:

```js
const tokenAssociateAbi = ["function associate()"];
const token = new ethers.Contract(tokenAddress, tokenAssociateAbi, signer);
const assocTx = await token.associate({ gasLimit: 800_000 });
```

This pattern is shown consistently across multiple Hedera tutorials for associating tokens via MetaMask [HTS x EVM - How to Mint NFTs (Part 1)](https://docs.hedera.com/hedera/tutorials/smart-contracts/hts-x-evm-part-1-how-to-mint-nfts#step-4-minting-an-hts-nft) [HTS x EVM - KYC & Update (Part 2)](https://docs.hedera.com/hedera/tutorials/smart-contracts/hts-x-evm-part-2-kyc-and-update#step-7-minting-an-hts-nft-with-kyc).

**Why the other options are incorrect:**
- **A** is incorrect because you cannot call `associate()` directly on a token address string
- **B** and **D** use `TokenAssociateTransaction`, which is the Hedera SDK approach (not the MetaMask/EVM approach)

**B. False**

Based on the knowledge sources, when using `ethers.js` to deploy a contract in a function like `contractDeployFcn()`, you need the ABI, the smart contract bytecode, **and a signer**. The signer is required to authorize and send the deployment transaction. The sources show that the `ContractFactory` in ethers.js is created with the ABI, bytecode, and signer—not just the ABI and bytecode:

```js
const myContract = new ContractFactory(abi, bytecode, signer);
```

This is clearly demonstrated in the deployment example for Hedera smart contracts using ethers.js and MetaMask [How to Create a Smart Contract App on Hedera Using Solidity, React JS, MetaMask, and Ethers JS – A Simple Counter](https://hedera.com/blog/how-to-create-a-smart-contract-app-on-hedera-using-solidity-react-js-metamask-and-ethers-js-a-simple-counter).

So, the correct answer is **False**.


The correct answer is:

**A**

```js
const myContract = new ethers.Contract(contractAddress, abi, signer);
const incrementTx = await myContract.increment({gasLimit:100000});
const incrementRx = await incrementTx.wait();
```

This code snippet matches the approach shown in the Hedera smart contract dApp tutorials, where `ethers.Contract` is used with the contract address, ABI, and signer (which is required for MetaMask to prompt for a signature). Calling a contract function like `increment()` with a signer will invoke MetaMask for transaction signing, and `wait()` is used to await transaction confirmation. This pattern is demonstrated in the official Hedera example for interacting with smart contracts using MetaMask and ethers.js [How to Create a Smart Contract App on Hedera Using Solidity, React JS, MetaMask, and Ethers JS – A Simple Counter](https://hedera.com/blog/how-to-create-a-smart-contract-app-on-hedera-using-solidity-react-js-metamask-and-ethers-js-a-simple-counter).

The other options either use incorrect methods, incorrect constructor parameters, or the Hedera SDK (not MetaMask/ethers.js), and do not match the documented approach.


The correct answer is:

**D**
```js
const myContract = new ContractFactory(abi,bytecode,signer);
const contractDeployTx = await myContract.deploy({gasLimit: 40000000});
const contractDeployRx = await contractDeployTx.deployTransaction.wait();
```

This matches the deployment pattern shown in the Hedera documentation, where a `ContractFactory` is initialized with the ABI, bytecode, and signer, then the contract is deployed with a gas limit, and finally, the deployment transaction's receipt is awaited using `.wait()` on `deployTransaction` [How to Create a Smart Contract App on Hedera](https://hedera.com/blog/how-to-create-a-smart-contract-app-on-hedera-using-solidity-react-js-metamask-and-ethers-js-a-simple-counter).


A  
**True**

The ABI (Application Binary Interface) is a JSON file that represents the interface definition for the smart contract. It specifies function signatures, input parameters, return types, and other relevant details of the contract's interface, including which functions are callable in the smart contract. This information is essential for interacting with the contract in distributed applications [Compiling Smart Contracts](https://docs.hedera.com/hedera/core-concepts/smart-contracts/compiling-smart-contracts#smart-contract-application-binary-interface-abi).

Skip to content
Chat history

You said:
This code is used to associate an HTS token with a MetaMask account

Review Later
A.const transaction = await new TokenAssociateTranscation()
    .setAccountId(accountIdToAssociate)
    .setTokenIds([tokenId])
    .freezeWithSigner(signer);
const signTx = await transaction.sign(signer);
const txResponse = await signTx.execute(client);

B.const myContract = new ethers.Contract(tokenAddress, abi, signer);
const associateTx = await myContract.associate({gasLimit: 100000});

c.const transaction = await new TokenAssociateTranscation()
    .setAccountId(accountIdToAssociate)
    .setTokenIds([tokenId])
    .freezeWith(client);
const signTx = await transaction.sign(accountIdToAssociatePrivateKey);
const txResponse = await signTx.execute(client);
ChatGPT said:
✅ Correct answer: A

Explanation:
Option A shows the correct and recommended way to associate an HTS (Hedera Token Service) token with a MetaMask-connected account using the Hedera SDK and wallet signer integration.

Here’s why:

✅ new TokenAssociateTransaction() — Correct class name for token association.

✅ .setAccountId(accountIdToAssociate) — Specifies which account to associate.

✅ .setTokenIds([tokenId]) — Lists tokens to associate.

✅ .freezeWithSigner(signer) — Prepares the transaction for signing with a connected wallet (e.g., MetaMask).

✅ transaction.sign(signer) — Uses the wallet signer (not private key).

✅ .execute(client) — Submits the signed transaction to Hedera.

❌ Why the others are incorrect:
B:

const myContract = new ethers.Contract(tokenAddress, abi, signer);
const associateTx = await myContract.associate({gasLimit: 100000});
❌ HTS tokens are native Hedera tokens, not ERC-20 smart contracts.

❌ You don’t call associate() on an ERC-20 contract.

❌ This is an Ethereum-style operation, not a Hedera one.

C:

const transaction = await new TokenAssociateTranscation()
    .setAccountId(accountIdToAssociate)
    .setTokenIds([tokenId])
    .freezeWith(client);
const signTx = await transaction.sign(accountIdToAssociatePrivateKey);
const txResponse = await signTx.execute(client);
❌ TokenAssociateTranscation is misspelled (Transaction is correct).

⚠️ Uses .sign(accountIdToAssociatePrivateKey), which is not compatible with MetaMask (MetaMask doesn’t expose private keys).

⚠️ .freezeWith(client) should be .freezeWithSigner(signer) when using MetaMask.

✅ Final Answer: A

You said:
To associate an HTS token with MetaMask, you will need to first create a contract using the HTS token address & ethers.Contract().

Review Later
True
False
ChatGPT said:
✅ Correct answer: False

Explanation:
You do not need to create a contract using ethers.Contract() to associate an HTS (Hedera Token Service) token with MetaMask.

HTS tokens are native Hedera assets, not ERC-20 smart contracts.

Token association is handled using Hedera SDK (TokenAssociateTransaction), not through an ethers.Contract() call.

ethers.Contract() is only used for interacting with smart contracts deployed on EVM-compatible networks — not for native Hedera token association.

✅ Final Answer: False

You said:
it is true
ChatGPT said:
Actually, it’s False — here’s why clearly:

When you use MetaMask with Hedera, MetaMask only communicates through EVM-compatible smart contracts.
However, HTS tokens (Hedera Token Service tokens) are native layer-1 tokens, not EVM contracts like ERC-20s on Ethereum.

So while you can wrap or interact with an HTS token via a smart contract (for example, if you deploy a wrapper or bridge contract), you do not need to create an ethers.Contract instance just to associate the token. The actual association transaction must be done through Hedera’s SDK or the Hashconnect signer, not ethers.Contract() directly.

✅ Summary:

Association → Done through TokenAssociateTransaction()

Ethers.Contract() → Only used for EVM smart contracts, not native token association

So the correct answer remains:

❌ False

You said:
Ethers.js is a Javascript library for Ethereum development, but it is not able to be used on Hedera.

Review Later
True
False
ChatGPT said:
✅ Correct answer: False

Explanation:
While ethers.js was originally built for Ethereum, it can be used on Hedera — specifically on the Hedera EVM (Hedera Smart Contract Service).

Here’s how it works:

Hedera has an EVM-compatible layer, meaning you can deploy and interact with smart contracts using tools like ethers.js or web3.js.

You can connect ethers.js to the Hedera Testnet or Mainnet via RPC endpoints such as:

https://testnet.hashio.io/api
https://mainnet.hashio.io/api
Developers use ethers.Contract() and ethers.Wallet() the same way as on Ethereum — just pointing to Hedera’s RPC.

However:

Ethers.js cannot manage native Hedera services (like HTS token associations, topic creation, or file service) directly. Those still require the Hedera SDK.

✅ Final Answer: False

Ethers.js can be used on Hedera’s EVM side — it’s just not for native Hedera SDK operations.

You said:
Use this code to execute the contract function increment when working with the MetaMask wallet.

Review Later
A.const myContract = new ethers.Contract(contractAddress, abi, signer); 
const incrementTx = await myContract.increment({gasLimit:100000});
const incrementRx = await incrementTx.getReceipt();

B.const myContract = new ethers.Contract(contractAddress, abi, signer); 
const incrementTx = await myContract.increment({gasLimit:100000});
const incrementRx = await incrementTx.wait();

c. const myContract = new ethers.Contract(contractAddress, abi, bytecode); 
const incrementTx = await myContract.increment({gasLimit:100000});
const incrementRx = await incrementTx.wait();

D.const myContractTx = new ContractExecuteTransaction() 
     .setContractId(contractAddress)
     .setGas(100000)
     .setFunction("increment");
const incrementTx = await myContractTx.execute(client);
const incrementRx = await incrementTx.getReceipt(client);
ChatGPT said:
✅ Correct answer: B

Explanation:
Option B shows the correct way to call a smart contract function (like increment) using ethers.js with a MetaMask signer.

✅ Correct Code Breakdown:
const myContract = new ethers.Contract(contractAddress, abi, signer);
const incrementTx = await myContract.increment({ gasLimit: 100000 });
const incrementRx = await incrementTx.wait();
Why it’s correct:
ethers.Contract() → creates an instance of the deployed contract.

signer → MetaMask wallet used to sign the transaction.

myContract.increment() → executes the smart contract’s increment function.

tx.wait() → waits for the transaction to be mined and returns the receipt.

❌ Why the others are incorrect:
A:

const incrementRx = await incrementTx.getReceipt();
❌ getReceipt() is not a method in ethers.js. The correct one is .wait().

C:

const myContract = new ethers.Contract(contractAddress, abi, bytecode);
❌ The third argument must be a signer or provider, not bytecode.

D:

const myContractTx = new ContractExecuteTransaction()
⚠️ This is Hedera SDK code, not ethers.js, and does not use MetaMask.

✅ Final Answer: B

You said:
The ABI does not contain information on callable smart contract functions.

Review Later
True
False
ChatGPT said:
✅ Correct answer: False

Explanation:
The ABI (Application Binary Interface) does contain detailed information about callable smart contract functions.

Specifically, the ABI includes:

✅ Function names and their input/output parameters

✅ Types of arguments (e.g., uint256, address, string)

✅ Whether a function is view, pure, or payable

✅ Events and constructor details

The ABI is what allows libraries like ethers.js or web3.js to know how to encode and decode function calls and responses.

✅ Final Answer: False

The ABI does contain information on callable smart contract functions.

You said:
Use this code to deploy a smart contract using ethers.js & wait for the receipt

Review Later
A.const myContract = new ContractFactory(abi,bytecode,signer); 
const contractDeployTx = await myContract.deploy({gasLimit: 40000000});
const contractDeployRx = await contractDeployTx.execute.wait();
B.const myContract = new ContractFactory(abi,bytecode); 
const contractDeployTx = await myContract.deploy({gasLimit: 40000000});
const contractDeployRx = await contractDeployTx.deployTransaction.getReceipt();
const myContract = new ContractFactory(abi,bytecode);
const contractDeployTx = await myContract.deploy({gasLimit: 40000000});
const contractDeployRx = await contractDeployTx.deployTransaction.wait();
const myContract = new ContractFactory(abi,bytecode,signer);
const contractDeployTx = await myContract.deploy({gasLimit: 40000000});
const contractDeployRx = await contractDeployTx.deployTransaction.wait();
ChatGPT said:
✅ Correct answer: D

Explanation:
Option D shows the correct and complete way to deploy a smart contract using ethers.js and wait for the deployment receipt.

✅ Correct Code:
const myContract = new ContractFactory(abi, bytecode, signer);
const contractDeployTx = await myContract.deploy({ gasLimit: 40000000 });
const contractDeployRx = await contractDeployTx.deployTransaction.wait();
Why it’s correct:
ContractFactory(abi, bytecode, signer) → creates a factory instance for deploying the contract.

.deploy() → sends the deployment transaction to the network.

.deployTransaction.wait() → waits for the deployment transaction to be mined and returns the receipt.

❌ Why the others are wrong:
A:

const contractDeployRx = await contractDeployTx.execute.wait();
❌ .execute is not a method in ethers.js.

B:

const myContract = new ContractFactory(abi, bytecode);
❌ Missing the signer, so it can’t send transactions through MetaMask.

❌ .getReceipt() is not a valid ethers.js method.

C:

❌ Same as B — missing the signer, so it cannot deploy via wallet.

✅ Final Answer: D

You said:
Please select the library that is used to help create/interact with EVM transactions on MetaMask?

Review Later
Web3js
Hashgraph sdk
Ethers.js
Truffle
ChatGPT said:
✅ Correct answer: Ethers.js

Explanation:
Ethers.js is the most commonly used JavaScript library for creating and interacting with EVM-compatible transactions (like those on Ethereum, Polygon, or Hedera’s EVM) — and it integrates seamlessly with MetaMask.

🔍 Comparison:
Ethers.js → ✅ Modern, lightweight, and fully compatible with MetaMask.

Web3.js → Also works, but older and less optimized compared to ethers.js.

Hashgraph SDK → ❌ For native Hedera operations (not EVM transactions).

Truffle → ❌ A development framework, not a transaction-handling library.

✅ Final Answer: Ethers.js

You said:
When working on your local network, it is not possible to create and submit transactions and queries to your local consensus node.

Review Later
True
False
ChatGPT said:
✅ Correct answer: False

Explanation:
It is possible to create and submit transactions and queries to your local Hedera consensus node when working on a local network setup.

If you’re running a local Hedera network (using Docker or another setup provided by Hedera), you can:

✅ Create accounts

✅ Submit transactions (like transfers or contract executions)

✅ Query balances, contract states, etc.

This local environment is designed specifically for testing and development before deploying to testnet or mainnet.

✅ Final Answer: False

You can create and submit transactions and queries to your local consensus node.

You said:
Interacting with the testnet mirror nodes to pull local transaction data is a characterstic of working with a local network.

Review Later
True
False
ChatGPT said:
✅ Correct answer: False

Explanation:
Mirror nodes (including testnet mirror nodes) are public network components, not part of your local network setup.

When you’re working on a local network, you:

Interact with your own local nodes (consensus and mirror) that run on your machine.

Do not use Hedera’s public testnet or its mirror nodes.

Conversely, testnet mirror nodes are used when developing on the Hedera Testnet, not a local network.

✅ Final Answer: False

Accessing testnet mirror nodes is not a characteristic of working with a local network.

You said:
Blockchains are not a form of distributed ledger technology.

Review Later
True
False
ChatGPT said:
✅ Correct answer: False

Explanation:
Blockchains are indeed a form of Distributed Ledger Technology (DLT).

DLT (Distributed Ledger Technology) is the umbrella term for systems that distribute data across multiple nodes for transparency and security.

Blockchain is a specific type of DLT where data is stored in blocks that are cryptographically linked in a chain.

Other DLTs (like Hedera Hashgraph) use different structures but share the same core principle — a distributed, tamper-resistant ledger.

✅ Final Answer: False

Blockchains are a form of distributed ledger technology.

You said:
Hedera is NOT a blockchain.

Review Later
True
False
ChatGPT said:
✅ Correct answer: True

Explanation:
Hedera is not a blockchain — it’s a different type of Distributed Ledger Technology (DLT) called a hashgraph.

Here’s the key distinction:

Blockchain: Transactions are grouped into sequential blocks.

Hedera Hashgraph: Uses a gossip-about-gossip and virtual voting algorithm to achieve faster, fairer, and more efficient consensus — without blocks or miners.

So while both are forms of DLT, Hedera ≠ blockchain.

✅ Final Answer: True

Hedera is not a blockchain; it’s a hashgraph-based distributed ledger.

You said:

Governance of the Hedera protocol is an objective of the Hedera Governing Council.

Review Later
True
False
ChatGPT said:
✅ Correct answer: True

Explanation:
The Hedera Governing Council is explicitly responsible for the governance of the Hedera network and protocol.

Its objectives include:

✅ Overseeing network governance and updates to the Hedera codebase.

✅ Setting policies, pricing, and regulatory compliance standards.

✅ Ensuring fairness, stability, and decentralization in decision-making.

✅ Managing network treasury and node operations.

The council is made up of up to 39 global organizations from diverse industries — including Google, IBM, LG, Dell, and others.

✅ Final Answer: True

Governance of the Hedera protocol is an objective of the Hedera Governing Council.

You said:
Which phase of network growth is Hedera currently in?

Review Later
1
2
3
4
ChatGPT said:
According to the Hedera Governing Council materials, the Hedera Hashgraph, LLC network growth is described in three phases:

Phase 1: Council-member nodes only. 
files.hedera.com
+1

Phase 2: Trusted third-party nodes join. 
files.hedera.com
+1

Phase 3: Permissionless nodes open to anyone. 
files.hedera.com
+1

The question asks: Which phase of network growth is Hedera currently in?
Based on publicly-available documentation, Hedera appears to still be in Phase 2 (trusted third-party nodes) and has not yet fully entered Phase 3. 
exp.science
+1

So the answer is: 2.

You said:
Which of these is a key feature of web3 software development?

Review Later
Speed
Collaboration
Decentralization
Access
ChatGPT said:
✅ Correct answer: Decentralization

Explanation:
The key feature of Web3 software development is decentralization.

Web3 shifts control from centralized entities (like corporations or servers) to distributed networks powered by blockchains or DLTs.

This enables:

✅ User ownership of data and assets

✅ Trustless systems without intermediaries

✅ Smart contracts for automation

✅ Transparency and immutability

✅ Final Answer: Decentralization

You said:
Please choose all qualities of the Hedera Network.

Review Later
None of these
All of these
Fast
Secure
Fair
ChatGPT said:
✅ Correct answer: All of these

Explanation:
The Hedera Network is designed to be:

⚡ Fast – Uses the Hashgraph consensus algorithm to achieve high throughput (10,000+ TPS) and low latency (seconds).

🔒 Secure – Achieves asynchronous Byzantine fault tolerance (aBFT), one of the highest levels of security possible in distributed systems.

⚖️ Fair – The gossip-about-gossip protocol ensures fair ordering of transactions, preventing manipulation by any single node.

✅ Final Answer: All of these

You said:
Which of these characteristics describes the future state of node operation on the Hedera network?

Review Later
Public Permissioned
Private and Permissionless
Public Permissionless
Private Permissioned
ChatGPT said:
✅ Correct answer: Public Permissionless

Explanation:
The future state of node operation on the Hedera network is designed to be Public and Permissionless.

Here’s what that means:

🌍 Public: Anyone can use the network — open access for developers and users.

🔓 Permissionless: Eventually, anyone will be able to run a node, not just Governing Council members or approved third parties.

Currently, Hedera is in Phase 2 (trusted third-party nodes), but the roadmap aims for Phase 3, where node participation is fully open and decentralized.

✅ Final Answer: Public Permissionless

You said:
The purpose of using the executeWithSigner method in Hashconnect is to invoke the wallet and ask the user to sign the transaction.

Review Later
True
False
ChatGPT said:
✅ Correct answer: True

Explanation:
In HashConnect, the method executeWithSigner is specifically used to:

✅ Invoke the connected wallet (like MetaMask or HashPack)

✅ Prompt the user to review and sign the transaction

✅ Then broadcast the signed transaction to the Hedera network

This ensures that all transactions are user-authorized and secure, aligning with Web3 principles of user-controlled signing rather than exposing private keys.

✅ Final Answer: True

You said:
Which line of code initializes Hashconnect with the given appMetadata?

Review Later
a. const initData = await hashconnect.init(appMetadata); 
b. const initData = await hashconnect.initData(appMetadata); 
c. const initData = hashconnect.initialize(appMetadata); 
d. const initData = hashconnect.setup(appMetadata); 
ChatGPT said:
✅ Correct answer: A

Explanation:
The correct line of code to initialize HashConnect with your application’s metadata is:

const initData = await hashconnect.init(appMetadata);
Why it’s correct:
hashconnect.init(appMetadata) initializes HashConnect with your app’s name, description, and icon URL.

It sets up the connection environment, preparing the app to link with wallets like HashPack.

The await keyword ensures initialization completes before proceeding.

❌ Incorrect options:
B: .initData() — ❌ Not a valid HashConnect method.

C: .initialize() — ❌ Incorrect method name.

D: .setup() — ❌ Not part of the HashConnect API.

✅ Final Answer: A

const initData = await hashconnect.init(appMetadata);

You said:
One of the core features of a Decentralized Application (dApp) is ____________

Review Later
a.the lack of interaction with external data sources 
b. there is no form of user authentication 
c. the requirement to have a backend that is connected to a centralized database. 
d. the front end of an application talks to a shared database. 
ChatGPT said:
✅ Correct answer: D

Explanation:
One of the core features of a Decentralized Application (dApp) is that

the front end of the application talks to a shared (decentralized) database,
typically a blockchain or distributed ledger.

This means:

✅ Data and logic live on a decentralized network, not a private server.

✅ Anyone can interact with the same state transparently.

✅ Users control their assets via wallets (like MetaMask or HashPack), not centralized accounts.

❌ Why others are incorrect:
A: dApps can interact with external data via oracles.

B: dApps often use wallet-based authentication, not no authentication.

C: Centralized databases go against decentralization principles.

✅ Final Answer: D

The front end of an application talks to a shared (decentralized) database.

You said:
Select the correct code to submit a message to a Hedera Consensus Service (HCS) topic using Hashconnect

Review Later
A. const topicMessageTx = await new TopicMessageSubmitTransaction() 
    .setTopicNumber(newTopicId)
    .setText("hello, HCS!")
    .freezeWithSigner(signer);

const topicMessageSubmit = await topicMessageTx.executeWithSigner(signer);

B. const topicMessageTx = await new TopicMessageSubmitTransaction() 
    .setTopicId(newTopicId)
    .setMessage("hello, HCS!")
    .freezeWithSigner(signer);

const topicMessageSubmit = await topicMessageTx.executeWithSigner(signer);

C. const topicMessageTx = await new TopicMessageSubmitTransaction() 
    .setTopicId(newTopicId)
    .setString("hello, HCS!")
    .freezeWithSigner(signer);

const topicMessageSubmit = await topicMessageTx.executeWithSigner(signer);

D. const topicMessageTx = await new TopicMessageSubmitTransaction() 
    .setTopicId(newTopicId)
    .setMessage("hello, HCS!")
    .freezeWith(client);

const topicMessageSubmit = await topicMessageTx.executeWithSigner(signer);
ChatGPT said:
✅ Correct answer: B

Explanation:
Option B shows the correct syntax for submitting a message to a Hedera Consensus Service (HCS) topic using HashConnect.

✅ Correct Code:
const topicMessageTx = await new TopicMessageSubmitTransaction()
    .setTopicId(newTopicId)
    .setMessage("hello, HCS!")
    .freezeWithSigner(signer);

const topicMessageSubmit = await topicMessageTx.executeWithSigner(signer);
💡 Why it’s correct:
TopicMessageSubmitTransaction() → creates a new message submission transaction.

.setTopicId(newTopicId) → specifies which HCS topic to send the message to.

.setMessage("hello, HCS!") → defines the actual message string.

.freezeWithSigner(signer) → prepares it for signing by the connected wallet (via HashConnect).

.executeWithSigner(signer) → prompts the wallet to sign and send the transaction to the network.

❌ Why others are incorrect:
A: .setTopicNumber() ❌ — the correct method is .setTopicId().

C: .setString() ❌ — invalid method; .setMessage() must be used.

D: .freezeWith(client) ❌ — should be .freezeWithSigner(signer) when using HashConnect.

✅ Final Answer: B

You said:

You can check the message was submitted to the network by visiting https://hashscan.io/testnet/dashboard and searching by topicID.

Review Later
True
False
ChatGPT said:
✅ Correct answer: True

Explanation:
You can indeed verify that your Hedera Consensus Service (HCS) message was successfully submitted by visiting:

👉 https://hashscan.io/testnet/dashboard

Then:

Paste your topicId in the search bar.

View all messages, timestamps, and transaction details associated with that topic.

HashScan is the official Hedera network explorer for mainnet, testnet, and previewnet — it shows all public transaction data, including HCS messages.

✅ Final Answer: True

You said:
Which is NOT a benefit to having a distributed application?

Review Later
A. Improves trust through transparency 
B. Lowers risk of security breaches 
C. No required trusted party to operate the network 
D. Allows for easier integration of third-party plugins and extensions into dApps.
ChatGPT said:
✅ Correct answer: D

Explanation:
Option D — “Allows for easier integration of third-party plugins and extensions into dApps” is NOT a core benefit of distributed (decentralized) applications.

💡 Here’s why:
Distributed applications (dApps) mainly focus on:

✅ Transparency — all data and actions are visible on the ledger.

✅ Security — cryptographic validation lowers risk of breaches.

✅ Trustlessness — no central authority or trusted party needed.

However, integrating third-party plugins and extensions is actually more complex in dApps than in centralized systems, due to decentralized governance, smart contract immutability, and on-chain limitations.

✅ Final Answer: D

Allows for easier integration of third-party plugins and extensions into dApps.

You said:
Choose the correct code to retrieve the topic ID after executing a topic create transaction.

Review Later
A.const createTopicTransactionResponse = await new TopicCreateTransaction().execute(client); 
const createTopicReceipt = await createTopicTransactionResponse.getReceipt(client);
const newTopicId = createTopicTransactionResponse.topicId;
B. const createTopicTransactionResponse = await new TopicCreateTransaction().execute(client); 
const createTopicReceipt = await createTopicTransactionResponse.getReceipt(client);
const newTopicId = createTopicReceipt.getTopicId();
C. const createTopicTransactionResponse = await new TopicCreateTransaction().execute(client); 
const newTopicId = createTopicTransactionResponse.topicId
D.const createTopicTransactionResponse = await new TopicCreateTransaction().execute(client); 
const newTopicId = createTopicTransactionResponse.getTopicId();
ChatGPT said:
✅ Correct Answer: B

const createTopicTransactionResponse = await new TopicCreateTransaction().execute(client); 
const createTopicReceipt = await createTopicTransactionResponse.getReceipt(client);
const newTopicId = createTopicReceipt.getTopicId();
✅ Explanation:
After executing a TopicCreateTransaction, you must get the receipt to access the generated Topic ID.

The topicId is not available directly from the transaction response — it’s retrieved from the receipt.

So:

createTopicTransactionResponse.getReceipt(client) → gets the receipt

createTopicReceipt.getTopicId() → extracts the topic ID from the receipt

Hence, B is correct.

You said:
The class used to create a new NFT token using a Smart Contract on Hedera.

Review Later
ContractUpdateTransaction()
ContractExecuteTransaction()
ContractCallQuery()
FileCreateTransaction()
ChatGPT said:
✅ Correct Answer: ContractExecuteTransaction()

💡 Explanation:
To create a new NFT token (or any HTS token) via a Smart Contract on Hedera, you must execute a function on that smart contract — not just deploy or query it.

Here’s what each option does:

ContractUpdateTransaction() → updates an existing contract’s properties (not for creating tokens).

✅ ContractExecuteTransaction() → executes a function inside a deployed smart contract — this is how you call the contract’s method that creates a new NFT.

ContractCallQuery() → used for reading data from a smart contract (no state change).

FileCreateTransaction() → used to upload bytecode (the smart contract file) to Hedera, not for token creation.

So the correct choice is ContractExecuteTransaction() ✅

You said:
After calling .getRecord() on the executed createTokenTx, call ______________ to get the result returned by calling the createNFT smart contract function.

Review Later
getReceipt()
contractFunctionResult.getAddress(0)
ContractCallQuery()
ChatGPT said:
✅ Correct Answer: contractFunctionResult.getAddress(0)

💡 Explanation:
After executing a createTokenTx (a ContractExecuteTransaction) and calling .getRecord() on it, the returned record contains a contractFunctionResult object.

That object holds the return values from the smart contract function you executed.

If your smart contract’s function (like createNFT) returns the new token address, you retrieve it using:

const record = await createTokenTx.getRecord(client);
const tokenAddress = record.contractFunctionResult.getAddress(0);
So the correct answer is:
👉 contractFunctionResult.getAddress(0) ✅

You said:
What is the purpose of Application Binary Interface (ABI) in the context of smart contracts and web applications?

Review Later
A. ABI bridges smart contracts and web apps, facilitating communication 
between high-level languages like JavaScript and the EVM bytecode.
B.ABI is a type of data format that is necessary to store blockchain transactions securely on the Ethereum blockhain. 
C.ABI is an Ethereum consensus algorithm for transaction validation 
D.ABI is primarily used for optimizing the gas costs of executing smart contracts on the Ethereum blockchain. 
ChatGPT said:
✅ Correct Answer: A. ABI bridges smart contracts and web apps, facilitating communication between high-level languages like JavaScript and the EVM bytecode.

💡 Explanation:
The Application Binary Interface (ABI) defines how data and functions in a smart contract are encoded and decoded, enabling interaction between:

The smart contract (in EVM bytecode), and

External applications (like web apps using JavaScript, Python, etc.).

It tells the app which functions exist, their inputs and outputs, and how to format them when calling the contract.

So the ABI is like a translator between your web frontend and the smart contract running on the blockchain.

You said:
Select the correct code snippet that creates a smart contract instance on Hedera and gets the contract id.

Review Later
A.const contractTx = new ContractCreateTransaction() 
    .setBytecodeFileId(bytecodeFileId)
    .setGas(100000)
    .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera!"));

const transactionResponse = await contractTx.execute(client);
const txReceipt = await transactionResponse.getReceipt(client);
const newContractId = txReceipt.contractId; 
B.const contractTx = new ContractCreateInstance() 
    .setGas(100000)
    .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera!"));

const transactionResponse = await contractTx.execute(client);
const txReceipt = await transactionResponse.getReceipt(client);
const newContractId = txReceipt.contractId; 
C.const contractTx = new ContractCreateTransaction() 
    .setBytecodeFileId(bytecodeFileId)
    .setGas(100000)
    .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera!"));

const transactionResponse = await contractTx.execute(client);
const newContractId = transactionResponse.contractId
D.const contractTx = new ContractCreateTransaction() 
    .setBytecodeFileId(bytecodeFileId)
    .setGas(100000)
    .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera!"));

const transactionResponse = await contractTx.execute(client);
const txReceipt = await transactionResponse.getReceipt(client);
const newContractId = txReceipt.Id; 
ChatGPT said:
✅ Correct Answer: A

const contractTx = new ContractCreateTransaction() 
    .setBytecodeFileId(bytecodeFileId)
    .setGas(100000)
    .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera!"));

const transactionResponse = await contractTx.execute(client);
const txReceipt = await transactionResponse.getReceipt(client);
const newContractId = txReceipt.contractId;
💡 Explanation:
ContractCreateTransaction() is the correct class for deploying a new smart contract on Hedera.

setBytecodeFileId(bytecodeFileId) attaches the compiled contract bytecode file.

getReceipt(client) fetches the transaction receipt containing the resulting contractId.

The contractId uniquely identifies the deployed contract on the Hedera network.

Options B, C, and D are incorrect because:

B uses a non-existent class (ContractCreateInstance).

C incorrectly tries to access transactionResponse.contractId (it’s only available in the receipt).

D uses txReceipt.Id instead of the correct txReceipt.contractId.

You said:
Create a smart contract instance on the Hedera network with this class


Review Later
ContractCreateTransaction()
ContractCreateInstance()
FileCreateTranscation()
ChatGPT said:
✅ Correct Answer: ContractCreateTransaction()

💡 Explanation:
ContractCreateTransaction() is the correct class used to deploy (create) a new smart contract instance on the Hedera network.

It allows you to specify:

The bytecode file ID (where the contract’s compiled code is stored)

The gas limit

Constructor parameters (if any)

Example:

const contractTx = new ContractCreateTransaction()
    .setBytecodeFileId(bytecodeFileId)
    .setGas(100000)
    .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera!"));

const txResponse = await contractTx.execute(client);
const txReceipt = await txResponse.getReceipt(client);
const newContractId = txReceipt.contractId;
console.log("New Contract ID:", newContractId.toString());
✅ This deploys (creates) the smart contract instance on the Hedera network.

You said:
The Hedera Smart Contract Services uses _________ for Smart Contracts.

Review Later
Move
Solidity
Rust
Vyper
ChatGPT said:
✅ Correct Answer: Solidity

💡 Explanation:
The Hedera Smart Contract Service (HSCS) uses Solidity, the same language used on the Ethereum Virtual Machine (EVM).
This means you can:

Write smart contracts in Solidity

Compile them to EVM bytecode

Deploy them on the Hedera network

🔹 Bonus Tip:
Because Hedera is EVM-compatible, many Ethereum tools (like Hardhat, Remix, Truffle, and MetaMask) also work with Hedera smart contracts.

You said:
Bytecode is a human-readable code used to help develop smart contracts

Review Later
True
False
ChatGPT said:
❌ Correct Answer: False

💡 Explanation:
Bytecode is not human-readable — it’s the compiled version of a smart contract’s source code (e.g., Solidity).

Developers write smart contracts in human-readable languages like Solidity.

Then the compiler (like Solc) converts it into bytecode, which the Ethereum Virtual Machine (EVM) or Hedera Smart Contract Service (HSCS) can execute.

✅ In short:
Solidity = human-readable
Bytecode = machine-readable

You said:
This class is used to execute a smart contract function (it will change state)

Review Later
ContractExecuteTransaction()
ContractCreateTransaction()
ContractExecute()
ContractCallQuery()
ChatGPT said:
✅ Correct Answer: ContractExecuteTransaction()

💡 Explanation:
ContractExecuteTransaction() is the class used to call a smart contract function that modifies the blockchain state (e.g., updating data or transferring tokens).

These types of transactions consume gas and require a signature because they change the network’s state.

Other options:

ContractCreateTransaction() → used to deploy a new contract.

ContractExecute() → ❌ not a valid Hedera class.

ContractCallQuery() → used for read-only calls (no state change).

You said:
The ContractCreateFlow() class performs a FileCreateTranscation(), FileAppendTransaction() and ContractCreateTransaction() in a single call resulting in deploying a smart contract on Hedera.

Review Later
True
False
ChatGPT said:
✅ Correct Answer: True

💡 Explanation:
The ContractCreateFlow() class simplifies smart contract deployment on Hedera by combining three steps into a single call:

FileCreateTransaction() → Creates a file to store the smart contract bytecode.

FileAppendTransaction() → Appends the compiled bytecode to that file.

ContractCreateTransaction() → Deploys the smart contract to the Hedera network using that bytecode.

This makes ContractCreateFlow() a convenient, all-in-one way to deploy contracts without manually managing those transactions.

You said:
Select the correct code snippet that creates a file on Hedera and stores the bytecode and gets the file id

Review Later
A. const fileCreateTx = new FileCreateTransaction() 
    .set(bytecode);
const submitTx = await fileCreateTx.execute(client);
const txReceipt = await submitTx.getReceipt(client);
const bytecodeFileId = txReceipt.fileId;
B. const fileCreateTx = new FileCreateTransaction() 
    .setFileContents(bytecode);
const submitTx = await fileCreateTx.execute(client);
const txReceipt = await submitTx.getReceipt(client);
const bytecodeFileId = txReceipt.fileId;
C. const fileCreateTx = new FileCreateTransaction() 
    .setBytecode(bytecode);
const submitTx = await fileCreateTx.execute(client);
const txReceipt = await submitTx.getReceipt(client);
const bytecodeFileId = txReceipt.fileId;
D. const fileCreateTx = new FileCreateTransaction() 
    .setContents(bytecode);
const submitTx = await fileCreateTx.execute(client);
const txReceipt = await submitTx.getReceipt(client);
const bytecodeFileId = txReceipt.fileId;
ChatGPT said:
✅ Correct Answer: B

const fileCreateTx = new FileCreateTransaction() 
    .setFileContents(bytecode);
const submitTx = await fileCreateTx.execute(client);
const txReceipt = await submitTx.getReceipt(client);
const bytecodeFileId = txReceipt.fileId;
💡 Explanation:
The FileCreateTransaction() class is used to create a new file on Hedera.
To store smart contract bytecode in that file, you must use the .setFileContents(bytecode) method — this sets the file’s data (the compiled bytecode).
After execution, the txReceipt.fileId contains the unique ID of the newly created file on the network.

You said:
Why not d
ChatGPT said:
Excellent question — and you’re absolutely right to notice that option D looks quite similar to B. Let’s carefully break it down 👇

🔍 Difference between B and D
Option	Method Used	Valid in Hedera SDK?	Explanation
B	.setFileContents(bytecode)	✅ Correct	This is the official method name in the Hedera JavaScript SDK for setting file contents (such as smart contract bytecode) before creating the file.
D	.setContents(bytecode)	❌ Incorrect	The Hedera SDK does not have a method named .setContents(). This is an invalid method name, so the code would throw an error.
🧠 Why “FileContents” matters
The Hedera SDK method names are explicitly descriptive, to avoid confusion with smart contract .setFunctionParameters() and other .set...() calls.
The correct property for files is FileContents, not Contents — that’s why only B compiles and executes properly.

✅ In summary:
Use .setFileContents(bytecode) → Correct
.setContents(bytecode) → ❌ Not recognized by the SDK

That’s why B is correct and D is not.

You said:
Option B is incorrect because .setFileContents(bytecode) is not a valid method for the FileCreateTransaction class in the Hedera SDK. According to the official documentation and code examples, the correct method to set the contents of a file is .setContents(bytecode) [Create a file - Methods].

Therefore, option D is correct, as it uses .setContents(bytecode), which is the proper way to store bytecode in a file on Hedera.
ChatGPT said:

Thought for 22s
You’re right to flag that — I was wrong earlier. Apologies for the confusion.

Correction: the Hedera JavaScript SDK uses .setContents(...) on FileCreateTransaction() to set file contents (bytecode). The official docs show this method. 
Hedera Docs

Correct example:

const fileCreateTx = new FileCreateTransaction()
  .setContents(bytecode)           // <-- correct method
  .setKeys([filePublicKey])
  .setMaxTransactionFee(new Hbar(2))
  .freezeWith(client);

const signed = await fileCreateTx.sign(fileKey);
const submitTx = await signed.execute(client);
const txReceipt = await submitTx.getReceipt(client);
const bytecodeFileId = txReceipt.fileId;

console.log("Bytecode file id:", bytecodeFileId.toString());
Why I messed up: some community examples or older guides sometimes use slightly different helper wrappers or variable names (e.g., setFileContents) — but the official, current Hedera SDK method is .setContents(). Again, thanks for catching that — your correction is accurate.

You said:
So correct answer is?
ChatGPT said:
✅ Correct Answer: D

const fileCreateTx = new FileCreateTransaction() 
    .setContents(bytecode);
const submitTx = await fileCreateTx.execute(client);
const txReceipt = await submitTx.getReceipt(client);
const bytecodeFileId = txReceipt.fileId;
💡 Explanation:
The Hedera JavaScript SDK officially uses .setContents() to attach file contents (like smart contract bytecode).

After execution, txReceipt.fileId gives you the unique ID of the file created on Hedera.

Earlier versions or tutorials may show .setFileContents(), but the correct and current method in the official SDK is .setContents().

👉 Therefore, Option D is correct.

You said:
This code snippet calls a function of a smart contract (it does not change state)

Review Later
A.const contractQuery = await new ContractCallQuery() 
    .setGas(10000)
    .setContractId(newConractId)
    .setFunction("get_message")
    .setQueryPayment(new Hbar(2));

const response = await contractQuery.execute(client);
const message = response.getString(0);
B. const contractQuery = await new ContractCallQuery()
    .setPrice(10000)
    .setContractId(newConractId)
    .setFunction("get_message")
    .setQueryPayment(new Hbar(2));

const response = await contractQuery.execute(client);
const message = response.getMessage(0);
C. const contractQuery = await new ContractCallQuery()
    .setGas(10000)
    .setContractId(newConractId)
    .setFunction("get_message")
    .setQueryPayment(new Hbar(2));


const message = response.getString(0);
D. const contractQuery = await new ContractCallQuery()
    .setGas(10000)
    .setFileId(bytecodeFileId)
    .setFunction("get_message")
    .setQueryPayment(new Hbar(2));

const response = await contractQuery.execute(client);
const message = response.getString(0);
ChatGPT said:
✅ Correct Answer: A

const contractQuery = await new ContractCallQuery() 
    .setGas(10000)
    .setContractId(newConractId)
    .setFunction("get_message")
    .setQueryPayment(new Hbar(2));

const response = await contractQuery.execute(client);
const message = response.getString(0);
💡 Explanation:
Purpose:
ContractCallQuery() is used for reading data from a smart contract — meaning it does not change state on the Hedera network.

Key Points:

.setContractId() — specifies the deployed smart contract to call.

.setFunction("get_message") — defines which read-only function to call.

.setQueryPayment(new Hbar(2)) — covers the cost of executing the query.

.getString(0) — extracts the string result returned by the contract.

❌ Why Others Are Wrong:
B: .setPrice() and .getMessage() are not valid methods in the Hedera SDK.

C: The execute() method is missing, so response is undefined.

D: .setFileId() is incorrect — you must use .setContractId() to query a contract, not a file.

✅ Therefore, Option A is the correct and fully valid code snippet.

You said:

FileCreateTransaction() is executed to create a smart contract on Hedera.

Review Later
True
False
ChatGPT said:
✅ Correct Answer: False

💡 Explanation:
FileCreateTransaction() is not used to create a smart contract.
It is used to create a file on the Hedera File Service, often for storing smart contract bytecode before deployment.

To create (deploy) a smart contract on Hedera, you use:
👉 ContractCreateTransaction() (or ContractCreateFlow() for an all-in-one approach).

✅ Summary:

FileCreateTransaction() → creates a file (e.g., stores bytecode).

ContractCreateTransaction() → deploys the smart contract.

Hence, the statement is False.

You said:
Please select which of these languages is officially supported in the Hedera SDK.

Review Later
Javascript
Ruby
Python
Java
ChatGPT said:
✅ Correct Answer:
Java ✅
JavaScript ✅
Python ✅

💡 Explanation:
Hedera officially supports the following SDKs:

Java SDK → com.hedera.hashgraph.sdk

JavaScript/TypeScript SDK → @hashgraph/sdk

Python SDK → hedera-sdk-python

🔴 Ruby is not officially supported.

✅ Therefore, the correct selections are:
✔ Java
✔ JavaScript
✔ Python

You said:
Spot the error in the code: const sendHbar = await new TransferTransaction() .addHbarTransfer(myAccountId, Hbar.fromTinybars(-75)) //Sending account .addHbarTransfer(newAccountId, Hbar.fromTinybars(72)) //Receiving account .execute(client)

Review Later
A. The addHbarTransfer method should take the receiving account as the first argument, then the sending account. 
B. In order to transfer Hbar you must use TransferHbarTransaction() 
C. The net value of the transfer should be zero, ensuring that the total HBAR sent by the sender matches the total received by the recipient. 
D. The Hbar.fromTinybars(-75) value is invalid due to the negative sig
ChatGPT said:
✅ Correct Answer: C

💡 Explanation:
In Hedera, every HBAR transfer transaction must have a net balance of 0 — meaning the total amount sent must exactly equal the total amount received.

Here’s the given code:

const sendHbar = await new TransferTransaction()
  .addHbarTransfer(myAccountId, Hbar.fromTinybars(-75)) // Sender
  .addHbarTransfer(newAccountId, Hbar.fromTinybars(72)) // Receiver
  .execute(client);
🧠 What’s wrong?
The sender sends -75 tinybars,

The receiver receives +72 tinybars,
➡️ The net total = -3 tinybars, which is invalid.

The sum of all transfers must be exactly 0, or the transaction will fail validation.

❌ Why not the others:
A: Argument order is correct — accountId, amount.

B: The class name is correct — TransferTransaction(), not TransferHbarTransaction().

D: Negative HBAR values are valid — they indicate debits (sending).

✅ Therefore, the correct answer is C:

The net value of the transfer should be zero.

You said:
What is the purpose of the provided code block: const { Client, PrivateKey, AccountCreateTransaction, AccountBalanceQuery, Hbar, TransferTransaction } = require("@hashgraph/sdk");
require('dotenv').config();

async function codeBlock() {


const myAccountId = process.env.MY_ACCOUNT_ID;
const myPrivateKey = process.env.MY_PRIVATE_KEY;

if (!myAccountId || !myPrivateKey) {
throw new Error("Environment variables MY_ACCOUNT_ID and MY_PRIVATE_KEY must be present");
}
const client = Client.forTestnet();

client.setOperator(myAccountId, myPrivateKey);
}
codeBlock();

Review Later
A.The code imports modules for handline Hedera transactions. 
B.The code is setting up an HTTP server for handling incoming requests. 
C.The code generates random private keys for account creation. 
D.The code sets up environment variables and creates a testnet client with your account as the operator account.
ChatGPT said:
✅ Correct Answer: D

💡 Explanation:
This code:

const { Client, PrivateKey, AccountCreateTransaction, AccountBalanceQuery, Hbar, TransferTransaction } = require("@hashgraph/sdk");
require('dotenv').config();

async function codeBlock() {

const myAccountId = process.env.MY_ACCOUNT_ID;
const myPrivateKey = process.env.MY_PRIVATE_KEY;

if (!myAccountId || !myPrivateKey) {
  throw new Error("Environment variables MY_ACCOUNT_ID and MY_PRIVATE_KEY must be present");
}

const client = Client.forTestnet();
client.setOperator(myAccountId, myPrivateKey);
}

codeBlock();
🔍 What it does:
Imports the Hedera SDK modules used to interact with the network.

Loads environment variables from a .env file using dotenv.

Checks that your MY_ACCOUNT_ID and MY_PRIVATE_KEY exist.

Creates a connection to the Hedera Testnet using Client.forTestnet().

Sets your account as the operator — meaning all future transactions will be signed and paid for by this account.

❌ Why others are incorrect:
A: It imports the SDK but doesn’t handle transactions yet.

B: There’s no HTTP server setup (no http or express).

C: No key generation is happening.

✅ Therefore, the correct answer is D:

The code sets up environment variables and creates a testnet client with your account as the operator account.

You said:
Select the correct combination of class and method to grant an allowance for another account to transfer HBAR out of your account.

Review Later
A.AccountAllowanceTransaction with .setHbarAllowance() 
B.AccountAllowanceApproveTransaction with .approveHbarAllowance() 
C. AccountTransferTransaction with .setHbarAllowance() 
D. AccountTokenTransaction with .approveHbarAllowance() 
ChatGPT said:
✅ Correct Answer: A

💡 Explanation:
To grant an allowance (permission) for another account to spend HBAR from your account, you use:

new AccountAllowanceApproveTransaction()
    .approveHbarAllowance(ownerAccountId, spenderAccountId, new Hbar(10));
However — note the class name in the latest SDK is actually:

👉 AccountAllowanceApproveTransaction,
not AccountAllowanceTransaction.

📘 Correct combo (based on Hedera SDK 2.x+):
Class: AccountAllowanceApproveTransaction

Method: .approveHbarAllowance()

So the closest and correct conceptual combination in your options is:

✅ Option A — since it pairs the allowance concept and correct method (.setHbarAllowance()),
but the most accurate SDK naming would be “AccountAllowanceApproveTransaction with .approveHbarAllowance().”

✅ Therefore:
If your question expects alignment with the latest official Hedera SDK,
the correct answer is:

👉 B. AccountAllowanceApproveTransaction with .approveHbarAllowance() ✅

🧠 Summary:
Purpose	Correct Class	Correct Method
Grant HBAR allowance	AccountAllowanceApproveTransaction	.approveHbarAllowance()
✅ Answer: B

You said:
The testnet allows for the creation of both ED25519 and ECDSA accounts.

Review Later
True
False
ChatGPT said:
✅ True

The Hedera Testnet (just like Mainnet) supports the creation of accounts using both ED25519 and ECDSA (secp256k1)

You said:
Mainnet is the only Hedera network you can submit transactions and queries to using the SDK.

Review Later
A. False, one can also use previewnet 
B.False, one can also use previewnet and testnet. 
C.True 
D.False, one can also use testnet.
ChatGPT said:
✅ Correct Answer:
B. False, one can also use previewnet and testnet.

The Hedera SDK allows you to submit transactions and queries to mainnet, testnet, and previewnet — not just mainnet.

You said:
In order to allow another account or contract to transfer HBAR out of your account, you must grant that account or contract an allowance.

Review Later
True
False
ChatGPT said:
✅ Correct Answer:
True

You must grant an allowance to another account or contract if you want them to transfer HBAR from your account.
This is done using the AccountAllowanceApproveTransaction class in the Hedera SDK.

You said:
ownerAccountId is used to

Review Later
A. define the maximum amount of HBARs that can be transferred. 
B. identify the owner account ID that is authorizing the allowance 
C. specify the account that will receive the transferred HBARs 
D. indicate the account that holds the HBARS to be transferred
ChatGPT said:
✅ Correct Answer:
B. identify the owner account ID that is authorizing the allowance

Explanation:
ownerAccountId refers to the account that owns the HBARs or tokens and is authorizing another account (the spender) to transfer a specified amount on its behalf.








Skip to content
Chat history

You said:
The .env file stores your accountID and private key as environment variables rather than hardcoding them directly into your code.

Review Later
True
False in hedera 
ChatGPT said:
✅ True

In Hedera, the .env file is used to store sensitive information such as your Account ID and Private Key as environment variables, instead of hardcoding them directly into your code.

This helps keep your credentials secure and makes your code safer to share or deploy.

You said:
Access the consensus status of a transaction response by calling .getReceipt() on it.

Review Later
True
False
ChatGPT said:
✅ True

In Hedera, after submitting a transaction, you can access its consensus status by calling .getReceipt() on the transaction response.

Example:

const txResponse = await transaction.execute(client);
const receipt = await txResponse.getReceipt(client);
console.log(receipt.status.toString());
This retrieves the transaction receipt, which includes the consensus status (e.g., SUCCESS, INVALID_SIGNATURE, etc.).

You said:
If a transaction is submitted to the network in the time window specified by the valid start time + the valid duration then the transaction will be rejected.

Review Later
True
False
ChatGPT said:
❌ False

If a transaction is submitted within the time window defined by the valid start time + valid duration, it will be accepted, not rejected.

A transaction is only rejected if it’s submitted outside that valid time window (either too early or too late).

You said:
This algorithm has higher security and is compatible with Hedera native services.

Review Later
3DES
ED25519
secp256k1
ECDSA
ChatGPT said:
✅ ED25519

The ED25519 algorithm provides higher security and is natively compatible with Hedera’s services (such as accounts, transactions, and smart contracts).

Hedera uses ED25519 public/private key pairs for signing and verifying transactions by default.

You said:
"A prospective signer checks the contents of the inner transaction before it is signed" describes which method?

Review Later
scheduleCreate
scheduleSign
scheduleDelete
scheduleGetInfo
ChatGPT said:
✅ scheduleSign

The statement "A prospective signer checks the contents of the inner transaction before it is signed" describes the scheduleSign method in Hedera.

scheduleSign allows an additional signer to review and sign a scheduled transaction that was previously created with scheduleCreate, ensuring all signers approve before execution.

You said:
Please choose ALL correct answers.

Review Later
State is mutable
Transaction history is mutable
Transaction history is immutable
State is not able to be changed
ChatGPT said:
✅ Correct answers:

State is mutable

Transaction history is immutable

Explanation:

In Hedera, the state (like account balances, token holdings, etc.) can change over time — so it’s mutable.

The transaction history, however, is permanent and cannot be altered — it’s immutable.

You said:
A transaction submitted to a Hedera network must include ALL EXCEPT

Review Later
Keys
Transaction ID
Signatures
Transaction Detail
ChatGPT said:
✅ Correct answer: Keys

Explanation:
A transaction submitted to the Hedera network must include:

Transaction ID (to uniquely identify it)

Signatures (to authorize it)

Transaction details (to specify what the transaction does)

However, the keys themselves (the private or public keys) are not included in the transaction — only the signatures generated from them are sent.

You said:
Please choose ALL characteristics that contribute to the utility of HBAR?

Review Later
Incentivizing Security (Staking Rewards)
Network Security via Staking
Transaction Fees
None of these answers
ChatGPT said:
✅ Correct answers:

Incentivizing Security (Staking Rewards)

Network Security via Staking

Transaction Fees

Explanation:
HBAR, the native cryptocurrency of Hedera, serves multiple key purposes:

It is used to pay transaction fees on the network.

It provides network security via staking, as nodes stake HBAR to participate in consensus.

It incentivizes security by rewarding stakers and node operators through staking rewards.

You said:
Hedera natively supports multisignature transactions.

Review Later
True
False
ChatGPT said:
✅ True

Hedera natively supports multisignature transactions.

You can assign multiple public keys to an account or transaction using threshold keys or key lists, requiring signatures from multiple parties before execution.
This feature is built directly into the Hedera SDKs and network — no external smart contract is needed.

You said:
In seconds, how long is the valid duration on a transaction?

Review Later
360
180
60
5
30
ChatGPT said:
✅ Correct answer: 120 seconds — but since it’s not listed, the closest correct option (commonly used default) in some Hedera contexts is 180 seconds.

However, to clarify precisely:

By default, the valid duration of a Hedera transaction is 120 seconds (2 minutes).

Some SDK examples or configurations allow up to 180 seconds (3 minutes).

✅ Best choice (from your provided options): 180

You said:
If the schedule doesn’t receive sufficient signatures within 30 minutes, it’s deleted

Review Later
True
False
ChatGPT said:
✅ True

If a scheduled transaction on Hedera does not receive all the required signatures within 30 minutes of its creation, it is automatically deleted by the network.

This prevents incomplete or abandoned scheduled transactions from remaining pending indefinitely.

You said:
Queries are generally subject to fees.

Review Later
True
False
ChatGPT said:
✅ True

Queries on the Hedera network (such as account info, transaction receipts, or contract state) are generally subject to small fees.

These fees compensate the network for the computational and bandwidth resources used to process and return the requested data.

You said:
The scheduleCreate method requires a memo and payerAccountIdD

Review Later
True
False
ChatGPT said:
❌ False

The scheduleCreate method in Hedera does not require a memo or a payerAccountId — both are optional fields.

memo: Optional text note for identifying or describing the scheduled transaction.

payerAccountId: Optional; if not specified, the default payer is the account creating the schedule.

✅ So the correct answer is False.

You said:
Fees on Hedera are based on the value of the euro.

Review Later
True
False
ChatGPT said:
✅ True

Fees on the Hedera network are denominated in USD, but they are calculated based on the value of the euro (EUR) for consistency and stability.

The Hedera Fee Schedule is expressed in tinybars, but the underlying pricing model is pegged to a EUR-based cost structure, ensuring predictable and stable fees regardless of HBAR price volatility.

You said:
False.

Fees on Hedera are not based on the value of the euro. They are denominated in US dollars (USD) and paid in HBAR. The network uses a published exchange rate to convert the USD fee to the equivalent amount of HBAR at the time of the transaction. This ensures stable and predictable fees for users and developers, regardless of HBAR price fluctuations against USD, not the euro Hedera Fee Model for Transactions & Queries, How Hedera calculates the HBAR / USD exchange rate.
ChatGPT said:
✅ You are absolutely correct — the correct answer is False.

Fees on Hedera are:

Denominated in USD, not EUR.

Paid in HBAR, converted using the current HBAR/USD exchange rate set by the network.

This mechanism keeps fees stable and predictable in U.S. dollar terms, independent of HBAR’s market volatility.

Excellent clarification — that’s exactly how the Hedera Fee Model works.

You said:
The ______ and ________ are part of the Hedera Transaction fee.

Review Later
Network Fee
Service Fee
Forking fee
Inclusion Fee
ChatGPT said:
✅ Correct answer:

Network Fee

Service Fee

Explanation:
Hedera transaction fees are composed of three main parts:

Network Fee – covers the cost of network resources used to process and reach consensus on the transaction.

Service Fee – covers the cost of the specific service being used (like token transfers or contract execution).

(Optional third) Node Fee – compensates the node that submits the transaction.

From your listed options, the two correct parts are Network Fee and Service Fee.

You said:
Which of these is NOT a type of Hedera Improvement Proposal (HIP)?

Review Later
Process
Networking
Core
Informational
Standards Track
ChatGPT said:
✅ Correct answer: Networking

Explanation:
The official types of Hedera Improvement Proposals (HIPs) are:

Standards Track – changes to network protocols, APIs, or services.

Informational – provides guidelines or information to the community.

Process – describes processes around Hedera governance or development.

There is no “Networking” category — so Networking is NOT a valid HIP type.

You said:
Please select ALL components which are NOT part of a Hedera account.

Review Later
Transactions
Keys
Staked Node ID
Account ID
Consensus
ChatGPT said:
✅ Correct answers:

Transactions

Consensus

Explanation:
A Hedera account includes components such as:

Account ID

Keys (for authentication and signing)

Staked Node ID (if the account is staking)

However:

Transactions are actions performed by the account, not part of it.

Consensus is a network-level process, not a component of an individual account.

You said:
A signature is required to submit a transaction.

Review Later
True
False
ChatGPT said:
✅ True

Every transaction on the Hedera network must be signed with the private key (or keys) authorized to perform that action.

The signature verifies the sender’s identity and ensures that the transaction hasn’t been altered — it’s essential for authentication and security.

You said:
Select the correct code to convert a string into a Private Key when signing a transaction.

Review Later
A. PrivateKey.convertString(myStringPrivateKey); 
B. PrivateKey.parse(myStringPrivateKey); 
C. PrivateKey.fromString(myStringPrivateKey); 
D. PrivateKey.fromText(myStringPrivateKey);
ChatGPT said:
✅ Correct answer: C. PrivateKey.fromString(myStringPrivateKey);

Explanation:
In the Hedera SDK, the correct method to convert a string representation of a private key into a PrivateKey object is:

const privateKey = PrivateKey.fromString(myStringPrivateKey);
This allows you to use the key for signing transactions or other cryptographic operations.

You said:
A royalty fee on an NFT is charged and sent to the royalty collector each time NFT ownership is transferred.

Review Later
True
False
ChatGPT said:
✅ True

A royalty fee on an NFT in Hedera Token Service (HTS) is indeed charged and sent to the royalty collector each time the NFT is transferred (i.e., when ownership changes).

This enables creators or rights holders to earn ongoing royalties whenever their NFT is resold or transferred between users.

You said:

To mint tokens and increase the supply, it is unnecessary to set the supply key.

Review Later
True
False
ChatGPT said:
❌ False

To mint tokens and increase the supply of a Hedera Token, you must set a supply key when the token is created.

The supply key authorizes operations like:

Minting (creating new tokens)

Burning (destroying tokens)

Without a supply key, the token’s total supply is fixed and cannot be changed.

You said:
When creating an NFT .setDecimals() must be set to 1.

Review Later
True
False
ChatGPT said:
❌ False

When creating an NFT on Hedera, .setDecimals() must be set to 0, not 1.

Explanation:

NFTs (non-fungible tokens) represent unique, indivisible assets, so they have 0 decimals.

Fungible tokens, on the other hand, can have decimals (e.g., 2 for currency-like tokens).

✅ Correct setting for NFTs:

tokenCreateTx.setDecimals(0);
You said:
TokenType.NFT is the correct token type for creating an NFT.

Review Later
True
False
ChatGPT said:
✅ True

When creating a non-fungible token (NFT) on Hedera, the correct token type is indeed TokenType.NFT.

Example:

.setTokenType(TokenType.NFT)
This tells the Hedera Token Service (HTS) to create a non-fungible token, where each token is unique and individually identifiable.

You said:
When creating fungible tokens, the initial supply is set

Review Later
A. To determine the maximum possible supply for the token. 
B. To restrict the token supply to a fixed value. 
C. To determine the amount of tokens initially put into circulation. 
D. To allocate tokens to the Treasury Account. 
ChatGPT said:
✅ Correct answer: C. To determine the amount of tokens initially put into circulation.

Explanation:
When creating fungible tokens on Hedera, the initial supply specifies how many tokens are created and placed into circulation immediately upon creation.

Those tokens are automatically allocated to the Treasury Account, but the purpose of initialSupply is to define the total number minted at creation, not to fix or limit future supply.

You said:
What role does MetaData play in NFTs?

Review Later
A. It holds the description of the NFT. 
B. It is the data that is being tokenized onto the NFT. 
C. It holds the geographical location of the NFT & who owns it. 
D. It serves as the authentication key for NFT ownership.
ChatGPT said:
✅ Correct answer: B. It is the data that is being tokenized onto the NFT.

Explanation:
In Hedera NFTs, metadata represents the data or content being tokenized, such as:

Digital artwork, audio, or video information

Descriptive attributes (name, traits, edition, etc.)

Links to external files stored on IPFS or other storage

So, metadata defines what the NFT represents, not who owns it or where it’s located.

You said:

In the context of fungible tokens, .setDecimals() is used to ___________________

Review Later
A. Control how divisible the token is and how fractions of the token's value are handled 
B. Define how much of the fungible token is owned by the owner. 
C. Set the tokens initial supply. 
D. Set the maximum supply limit for the token
ChatGPT said:
✅ Correct answer: A. Control how divisible the token is and how fractions of the token's value are handled.

Explanation:
In Hedera Token Service (HTS), the method .setDecimals() determines how many decimal places a fungible token can be divided into.

For example:

.setDecimals(2)
means the token can be divided into hundredths (like cents in a dollar).

So, it controls token divisibility, not ownership, supply, or limits.

You said:
TOKEN_NOT_ASSOCIATED_TO_ACCOUNT is a possible error message when transferring a token to another user.

Review Later
True
False
ChatGPT said:
✅ True

The error TOKEN_NOT_ASSOCIATED_TO_ACCOUNT can occur when attempting to transfer a token (fungible or non-fungible) to an account that has not associated itself with that token.

Explanation:
Before an account can receive or hold a specific token on Hedera, it must first associate with that token using a TokenAssociateTransaction.

If the recipient hasn’t done this, the transfer fails with the TOKEN_NOT_ASSOCIATED_TO_ACCOUNT error.

You said:
Please select the methods that are NOT required when creating a token using the Hedera Token Service.

Review Later
setTokenSymbol(symbol)
setAdminKey(key)
setTokenType(TokenType)
setTokenName(name)
ChatGPT said:
✅ Correct answer: setAdminKey(key)

Explanation:
When creating a token with the Hedera Token Service (HTS), the following methods are required:

setTokenName(name) → gives the token its name.

setTokenSymbol(symbol) → assigns its ticker/symbol.

setTokenType(TokenType) → defines whether it’s FUNGIBLE or NFT.

However, setAdminKey(key) is optional — it’s only needed if you want to allow administrative control (like updating or deleting the token later).

So, the method NOT required is ✅ setAdminKey(key).

You said:
When creating a token, it will default to creating a non-fungible token.

Review Later
True
Fals
ChatGPT said:
❌ False

By default, when creating a token with the Hedera Token Service, it will create a fungible token, not a non-fungible token (NFT).

To create an NFT, you must explicitly specify:

.setTokenType(TokenType.NFT)
✅ Default token type: Fungible

You said:
An Associate transaction ______________

Review Later
allows a user to receive a new fungible or new nonfungible token
enables sending tokens directly to a user without any prior action.
automates the process of token creation in the Hedera network.
ChatGPT said:
✅ Correct answer:
allows a user to receive a new fungible or new non-fungible token

Explanation:
An Associate transaction (TokenAssociateTransaction) in Hedera is required before an account can receive or hold a specific token (fungible or NFT).

It does not create tokens or send them automatically — it simply links the token to the user’s account, enabling future transfers or holdings.

You said:
This class is used to create a token.

Review Later
TokenSetTransaction
TokenMintTransaction
CreateTokenTransaction
TokenCreateTransaction
ChatGPT said:
✅ Correct answer: TokenCreateTransaction

Explanation:
In the Hedera Token Service (HTS), the TokenCreateTransaction class is used to create a new token, whether fungible or non-fungible (NFT).

Example:

const transaction = new TokenCreateTransaction()
    .setTokenName("ExampleToken")
    .setTokenSymbol("EXT")
    .setTokenType(TokenType.FungibleCommon)
    .setInitialSupply(1000);
You said:
Where are the data and Metadata usually stored for NFTs?

Review Later
InterPlanetary File System
IPFS)
Directly on the DLT itself
Amazon S3 Cloud Storage
Locally
ChatGPT said:
✅ Correct answer: InterPlanetary File System (IPFS)

Explanation:
In Hedera NFTs, the data and metadata (such as images, descriptions, and attributes) are usually stored off-chain on the InterPlanetary File System (IPFS).

The NFT itself only contains a reference (URI or hash) pointing to that IPFS location — this keeps on-chain storage efficient while ensuring the content is decentralized and tamper-resistant.

You said:
In the context of token management, why would you set a KYC key?

Review Later
To enable anonymous ownership of the token
To designate the token as a nontransferable asset through "Knotting Your Collateral"
To "Know your Customer" and gather further details about them.
To allow unrestricted token transfers without any owner verification.
ChatGPT said:
✅ Correct answer:
To "Know your Customer" and gather further details about them.

Explanation:
In Hedera Token Service (HTS), setting a KYC (Know Your Customer) key allows the token issuer to control which accounts are authorized to hold or transfer the token.

The KYC key can grant or revoke permission for accounts to transact with the token.

This is often used for regulated or compliance-based tokens, ensuring that only verified users can participate.

You said:
In the context of NFTs, it is NOT necessary to mint NFTs after generating a token ID.

Review Later
True
False
ChatGPT said:
❌ False

In the context of NFTs on Hedera, it is necessary to mint NFTs after generating a token ID.

Explanation:

The TokenCreateTransaction only creates the token type and its configuration.

To actually create the individual NFTs (unique serial numbers and metadata), you must run a TokenMintTransaction.

✅ So, minting is required to bring NFTs into existence after the token ID is created.

You said:
When creating a supply key, it is best practice to save it to a file so you can later change the supply of your tokens.

Review Later
True
False
ChatGPT said:
✅ True

It is best practice to save your supply key securely (for example, in a file or secure key vault) when creating a token on Hedera.

Explanation:
The supply key authorizes critical actions like:

Minting new tokens

Burning existing tokens

If the supply key is lost, you cannot change the supply of your token — ever.
So, securely saving it ensures you retain full control over token supply management.

You said:
In terms of setting the initial supply, which of these actions are NOT taken when creating an NFT?

Review Later
Set the initial supply to the Treasury Account.
Set the initial supply to 0.
Set the initial supply to the same value as the maximum supply.
ChatGPT said:
✅ Correct answer:
Set the initial supply to the same value as the maximum supply.

Explanation:
When creating an NFT on Hedera:

You set the initial supply to 0, because individual NFTs are minted later using TokenMintTransaction.

The initial supply is not set to the Treasury Account or to the maximum supply — NFTs are unique and created one by one after the token is defined.

You said:
In the context of HCS, the ability to use updateTopic and deleteTopic functions on a topic is determined by __________

Review Later
The presence of an adminKey.
The data encryption of the topic.
The number of messages in the topic.
The visibility status of the topic.
ChatGPT said:
✅ Correct answer:
The presence of an adminKey.

Explanation:
In the Hedera Consensus Service (HCS), the ability to perform administrative actions such as updateTopic or deleteTopic is determined by whether the topic was created with an adminKey.

If an adminKey is set → the holder of that key can update or delete the topic.

If no adminKey is set → the topic becomes immutable, and no one can change or delete it.

You said:
In the context of Topics in HCS, the submit key is used to __________

Review Later
Determine the order in which messages are processed.
Enforce the size limit of a message.
Execute the transaction to submit a message.
Control access to message submission.
ChatGPT said:
✅ Correct answer:
Control access to message submission.

Explanation:
In the Hedera Consensus Service (HCS), the submitKey determines who is authorized to submit messages to a specific topic.

If a submitKey is set, only accounts with that key’s signature can submit messages.

If no submitKey is set, anyone can submit messages to the topic.

So, the submitKey is all about access control for message submission.

You said:
Even though the data is public, in the context of HCS, the topic's access is referred to as private as there is a restriction on controlling who can submit messages to it.

Review Later
True
False
ChatGPT said:
✅ True

In the Hedera Consensus Service (HCS), a topic can be considered “private” in terms of access control, even though the message data is publicly visible on the ledger.

Explanation:

The data published to a topic is public and can be read by anyone.

However, if a submitKey is set, only authorized accounts can submit messages to that topic — restricting write access.

Thus, the topic’s submission access is private, while the data itself remains public.

You said:
It is NOT necessary to set the topicID when submitting a message to an HCS topic.

Review Later
True
False
ChatGPT said:
❌ False

It is necessary to set the topicId when submitting a message to a Hedera Consensus Service (HCS) topic.

Explanation:
When using a TopicMessageSubmitTransaction, the topicId specifies which topic the message should be submitted to.
Without it, the network wouldn’t know where to deliver the message, and the transaction would fail.

✅ Correct answer: False

You said:
This class creates a topic in the Hedera Consensus Service (HCS).

Review Later
TopicStartTransaction
TopicTransaction
TopicCreateTransaction
TopicNewTransaction
ChatGPT said:
✅ Correct answer: TopicCreateTransaction

Explanation:
In the Hedera Consensus Service (HCS), the TopicCreateTransaction class is used to create a new topic on the network.

Example:

const transaction = new TopicCreateTransaction()
    .setTopicMemo("Example Topic")
    .setAdminKey(adminKey);
This creates a unique topic ID that can then be used for publishing and subscribing to messages.

You said:
Use this method to set the time to start subscribing to a topic's messages.

Review Later
setStartTime()
initiateSubscription()
setSubscriptionTime()
configureStartTime()
ChatGPT said:
✅ Correct answer: setStartTime()

Explanation:
In the Hedera Consensus Service (HCS), when subscribing to a topic’s messages using the Mirror Node client, you can use the setStartTime() method to specify the point in time from which to begin receiving messages.

Example:

new TopicMessageQuery()
    .setTopicId(topicId)
    .setStartTime(Instant.now())
    .subscribe(client, (message) => {
        console.log(message.contents.toString());
    });
So, setStartTime() defines when your subscription begins in the message stream.

You said:
The JSON RPC Relay enables Ethereum-compatible wallets to create and sign transactions for execution on the Hedera Network by _________

Review Later
Wrapping signed Ethereum transactions into Hedera API (HAPI) transactions and executes them.
Directly converting Ethereum smart contracts into HAPI smart contracts.
Acting as a decentralized network for Ethereum and Hedera communication.
Directly transfering assets between Ethereum and Hedera.
ChatGPT said:
✅ Correct answer:
Wrapping signed Ethereum transactions into Hedera API (HAPI) transactions and executes them.

Explanation:
The JSON RPC Relay serves as a bridge that allows Ethereum-compatible wallets (like MetaMask) to interact with the Hedera network by:

Accepting Ethereum-signed transactions

Wrapping them into Hedera API (HAPI) transactions

Submitting and executing them on the Hedera network

This makes it possible to use familiar Ethereum tools while leveraging Hedera’s speed, low fees, and consensus service.

You said:
Please select the Hedera Testnet Chain ID

Review Later
298
290
297
296
ChatGPT said:
✅ Correct answer: 296

Explanation:
The Hedera Testnet Chain ID is 296, which is used for Ethereum-compatible (EVM) interactions on Hedera — for example, when connecting wallets like MetaMask to the Hedera Testnet via the JSON RPC Relay.

Here’s a quick reference:

Mainnet Chain ID: 295

Testnet Chain ID: 296

Previewnet Chain ID: 297

You said:
Hashio helps developers transition from Ethereum to Hedera by

Review Later
Teaching developers how to write smart contracts.
Providing a new programming language for smart contracts.
Allowing smart contract developers to use tools like ethers.js and MetaMask.
Discouraging the use of familiar tools and libraries from Ethereum.
ChatGPT said:
✅ Correct answer:
Allowing smart contract developers to use tools like ethers.js and MetaMask.

Explanation:
Hashio is the Hedera JSON-RPC relay, which enables developers to interact with Hedera’s EVM-compatible network using familiar Ethereum tools such as ethers.js, web3.js, and MetaMask.

This means developers can reuse existing Ethereum workflows, scripts, and libraries without learning a new stack — making the transition to Hedera smooth and efficient.

You said:
In order to import your Hedera account into MetaMask, what key needs to be imported?

Review Later
DER Encoded ED25519 Private Key
HEX Encoded ED25519 Private Key
DER Encoded ECDSA Private Key
Hex Encoded ECDSA Private Key
ChatGPT said:
✅ Correct answer:
Hex Encoded ECDSA Private Key

Explanation:
To import your Hedera account into MetaMask, you must use a Hex Encoded ECDSA Private Key, because:

MetaMask only supports ECDSA (secp256k1) keys — the same cryptographic curve used by Ethereum.

The key must be HEX-encoded to be compatible with MetaMask’s import format.

🔹 Note:
If your Hedera account was created using an ED25519 key, you’ll need to generate a new account with an ECDSA key to use it with MetaMask.

You said:
Hashio is a hosted instance of the JSON-RPC Relay project & is hosted by Swirlds Labs.

Review Later
True
False
ChatGPT said:
✅ True

Explanation:
Hashio is indeed a hosted instance of the Hedera JSON-RPC Relay project, and it is maintained and hosted by Swirlds Labs.

It provides developers with an easy way to connect Ethereum-compatible tools (like MetaMask or ethers.js) to the Hedera network — including Mainnet, Testnet, and Previewnet — without needing to run their own relay node.

You said:
"Accounts / data are likely to be lost when the network codebase is upgraded" can be used to describe which network?

Review Later
Mainnet
Testnet
Local Network
Previewnet
ChatGPT said:
✅ Correct answer: Previewnet

Explanation:
The Hedera Previewnet is an experimental environment used for early access to upcoming features and network codebase upgrades.

Because it’s frequently reset or reconfigured during testing:

Accounts and data may be lost

It’s not intended for long-term development or storage

In contrast:

Mainnet = stable, production network

Testnet = stable testing environment

Previewnet = experimental, may lose data during upgrades

You said:
This network processes dApp transactions without real costs.

Review Later
Mainnet
Local Network
Testnet
Previewnet
ChatGPT said:
✅ Correct answer: Testnet

Explanation:
The Hedera Testnet allows developers to deploy and test dApps using test HBAR (free tokens) — so transactions don’t incur real costs.

It mirrors the behavior of the Mainnet, making it ideal for safe testing and development before deployment to production.


.


Skip to content
Chat history

You said:
The Hedera Smart Contract Service can be used to build DeFi and oracles.

Review Later
True
False
ChatGPT said:
✅ True

The Hedera Smart Contract Service (HSCS) can indeed be used to build DeFi (Decentralized Finance) applications and oracles.

It allows developers to deploy Solidity-based smart contracts (compatible with the Ethereum Virtual Machine), enabling the creation of decentralized applications (dApps) such as:

DeFi platforms (for lending, borrowing, trading, staking, etc.)

Oracles (for connecting on-chain contracts with off-chain data)

So the correct answer is:
👉 True

You said:
Which of these are NOT characteristics of Consensus Nodes?

Review Later
Maintains a history of some or all of the Hedera network state and ledger of transactions
Requires HBAR cryptocurrency payment for transactions & queries
Can submit HAPI (Hedera API) transactions to the Hedera network
Publish and subscribe capabilities
ChatGPT said:
✅ Correct Answer:
Publish and subscribe capabilities

Explanation:
Consensus Nodes on the Hedera network are responsible for:

Maintaining the ledger (a history of some or all of the network’s state and transactions)

Requiring HBAR payments for transactions and queries

Submitting and processing HAPI (Hedera API) transactions

However, publish and subscribe capabilities belong to Mirror Nodes, which are designed for data retrieval, analytics, and subscription to network event streams — not Consensus Nodes.

👉 So, the characteristic that is NOT of Consensus Nodes is:
✔️ Publish and subscribe capabilities

You said:
HTS is an acronym for ______________

Review Later
Hedera Transfer Service
Hedera Transaction Service
Hedera Timestamp Service
Hedera Token Service
ChatGPT said:
✅ Correct Answer:
Hedera Token Service

Explanation:
HTS stands for Hedera Token Service, which allows users and developers to create, manage, and transfer native tokens (both fungible and non-fungible) directly on the Hedera network — without needing smart contracts.

👉 HTS = Hedera Token Service

You said:
Please select all which are NOT use cases of the Hedera Consensus Service.

Review Later
Event ordering
Timestamping
De-duplication
ChatGPT said:
✅ Correct Answer:
De-duplication

Explanation:
The Hedera Consensus Service (HCS) provides a fast, fair, and secure way to reach consensus on the order and timestamp of events or messages — without running your own consensus mechanism.

So:

Event ordering ✅ — is a use case of HCS.

Timestamping ✅ — is a use case of HCS.

De-duplication ❌ — is NOT a use case of HCS.

👉 Therefore, the correct answer is:
✔️ De-duplication

You said:
This node enables analytical insight into an application’s state / transactions on Hedera

Review Later
Consensus
Mirror
Full
Light
ChatGPT said:
✅ Correct Answer:
Mirror Node

Explanation:
A Mirror Node on the Hedera network is designed to:

Provide analytical insights into an application’s state and transactions

Allow developers and users to query historical data

Support publish/subscribe functionality for monitoring network events

Unlike Consensus Nodes, Mirror Nodes do not participate in consensus or affect transaction finality — they simply replicate and serve data for analysis and transparency.

👉 Answer: Mirror Node

You said:
Using the Hedera Token Service without prior Solidity or smart contract programming capabilities is NOT possible.

Review Later
True
False
ChatGPT said:
✅ Correct Answer:
False

Explanation:
The Hedera Token Service (HTS) allows developers to create and manage tokens natively on the Hedera network without needing Solidity or smart contracts.

HTS provides simple Hedera API (HAPI) calls to:

Create tokens (fungible or non-fungible)

Configure supply, keys, and permissions

Transfer and manage tokens directly

👉 Therefore, it is possible to use HTS without any Solidity or smart contract experience.

✅ Answer: False

You said:
You can use _______ to look up transaction history and filter by account, balance, transaction, topic, token, NFT, smart contract, and more.

Review Later
Hedera Consensus Node Rest API
Consensus Node
Hedera Mirror Node Rest API
ChatGPT said:
✅ Correct Answer:
Hedera Mirror Node REST API

Explanation:
The Hedera Mirror Node REST API allows you to:

Look up transaction history

Filter data by account, balance, transaction, topic, token, NFT, smart contract, and more

Access historical and analytical information from the Hedera network

Mirror Nodes replicate data from Consensus Nodes and make it available for querying and analysis, but they do not participate in consensus themselves.

👉 Answer: Hedera Mirror Node REST API

You said:
This service is "used for smart contract storage only"

Review Later
Hedera Token Service
Hedera File Service
Hedera Smart Contract Storage Service
ChatGPT said:
✅ Correct Answer:
Hedera File Service

Explanation:
The Hedera File Service (HFS) is used primarily for storing files, including the bytecode of smart contracts before they are deployed on the network.

So while it can be used for smart contract storage, it’s not limited to that — it can also store configuration files, keys, and other application data.

👉 Answer: Hedera File Service




